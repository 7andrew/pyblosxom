<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
<bookinfo>
<title>PyBlosxom Manual</title>

<!--
  If you do any editing on this document, add your name to the below
  author list.
-->
<authorgroup>
<author><firstname>Will</firstname><surname>Guaraldi</surname></author>
</authorgroup>

<edition>PyBlosxom Manual for PyBlosxom 1.2</edition>

<copyright>
  <year>2005</year>
  <holder>Will Guaraldi</holder>
</copyright>

<legalnotice>
<para>
Copyright (c) 2005 Will Guaraldi.  Permission is granted to copy, distribute 
and/or modify this document under the terms of the GNU Free Documentation License, 
Version 1.1 or any later version published by the Free Software Foundation; with 
the Invariant Sections being no Invariant Sections, with the Front-Cover Texts being 
no Front-Cover Texts, and with the Back-Cover Texts being no Back-Cover Texts.  A 
copy of the license is included in the appendix entitled "GNU Free Documentation 
License".
</para>
</legalnotice>
</bookinfo>

<toc></toc>

<!--
  INTRODUCTION
-->
<preface id="introduction">
<title>Introduction</title>
<sect1>
<title>Mission, What's Missing, and Helping Out</title>
<para>
The mission of this manual is to cover all aspects of using and developing for
PyBlosxom.  It is very much a work in progress and this manual is by no means
comprehensive at this point.  However, we do promise that the manual will get
better over time.
</para>
<para>
There's no list of what's missing, however, there are a series of FIXMEs
placed around the document with some details as to what needs to be provided
and/or fixed.  I'm sure there are things missing that have been completely
overlooked as well.
</para>
<para>
If you want to help out with documentation, let us know on the pyblosxom-devel
mailing list.  If you notice errors, missing pieces, sections that are unclear, 
examples that are erroneous, or anything else, let us know on the pyblosxom-devel 
mailing list.
</para>
<para>
Details on the mailing list are on the web-site at http://pyblosxom.sourceforge.net/ .
</para>
</sect1>

<sect1>
<title>Revision History</title>
<para>
The following is a revision history of this document:
</para>

<revhistory>

<revision>
  <revnumber>0.5</revnumber>
  <date>21 March 2005</date>
  <authorinitials>wbg</authorinitials>
  <revremark>
    Converted from html to docbook; rewrote chapters on installation and flavours;
    removed chapter on configuration (folded into installation); added a chapter
    on writing entries (not sure how I missed an obvious subject like that the
    first few times around); and tidied some things up.  This version of the 
    manual goes with PyBlosxom 1.2.
  </revremark>
</revision>

</revhistory>

</sect1>
</preface>


<!--
  CHAPTER INSTALLATION
-->
<chapter id="installation">
<title>Installing PyBlosxom</title>
<para>
There are many ways to install PyBlosxom. This particular installation 
guide covers the typical installation for a single user on Apache with 
PyBlosxom running as a CGI script.
</para>
<para>
There are other ways to install Pyblosxom depending on how you want it 
to behave as well as what webserver you're installing Pyblosxom on top of.
</para>
<para>
This installation assumes you have some understanding of CGI, Apache 
configuration, and know how to manipulate files and directories. If this 
doesn't sound like you, maybe you should get a friend to help out or ask 
for help on the pyblosxom-users mailing list.
</para>
<para>
If you are upgrading your version of PyBlosxom, follow the instructions 
here and also read the README that comes with your PyBlosxom tarball for 
differences between this version and the previous versions.
</para>

<sect1>
<title>Pre-requisites</title>
<para>
You will need:
</para>
<itemizedlist>
<listitem>
<para>
a web-server that runs CGI
</para>
</listitem>
<listitem>
<para>
Python version 2.2 or later
</para>
</listitem>
<listitem>
<para>
a text editor (notepad, vi, emacs, nano, ...) 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1>
<title>Installing PyBlosxom</title>
<para>
First you should download the PyBlosxom tar ball from 
http://pyblosxom.sourceforge.net/ .  Then untar it.
</para>

<sect2>
<title>Single-user Installation</title>
<para>
If you don't have administrative/root access, you just want to install 
PyBlosxom for your user account, or you merely want to try PyBlosxom out, 
do the following:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
copy pyblosxom.cgi and config.py from the web/ directory into your 
cgi-bin directory
</para>
</listitem>
<listitem>
<para>
using any text editor, edit your config.py file and set the codebase 
property to the directory that PyBlosxom is in
</para>
<para>
For example, if you untarred PyBlosxom into /home/joe/pyblosxom, then set the codebase
property like this:
</para>
<programlisting role="python">
py["codebase"] = "/home/joe/pyblosxom/"
</programlisting>
<para>
If you're using Windows, use an explicit path like this:
</para>
<programlisting role="python">
py["codebase"] = "c:\\pyblosxom\\"
</programlisting>
</listitem>
</orderedlist>
</sect2>

<sect2>
<title>Multi-user Installation</title>
<para>
If you have administrative/root access and you want to install PyBlosxom so that all
your users can use it from a centralized installation, do the following:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
untar the pyblosxom tar file into a temporary directory
</para>
</listitem>
<listitem>
<para>
switch over to a superuser such as root
</para>
</listitem>
<listitem>
<para>
run the command "python setup.py install" to install the Pyblosxom libraries 
in your python installation 
</para>
<para>
when users go to setup PyBlosxom, they'll need the config.py and 
pyblosxom.cgi files that will get copied to a directory in /usr/share 
on Unix/Linux systems
</para>
<para>
FIXME - where do these files go on Windows and OSX?
</para>
</listitem>
</orderedlist>
</sect2>
</sect1>

<sect1>
<title>Setting up PyBlosxom</title>
<para>
After you've performed one of the installations in the previous section, 
you're ready to set up PyBlosxom.  These steps set up PyBlosxom for a 
single person.  For multiple, just do them again
and again and again.
</para>

<sect2>
<title>Create a datadir Directory</title>
<para>
PyBlosxom stores its entries in text files in your datadir.  The datadir 
can contain directories each of which will be a category for PyBlosxom.  
In general, it's good to use one-word names for directories that don't have 
spaces or punctuation in them.
</para>
<para>
Create a datadir somewhere on your machine.  For example, if you're a 
single user on a Linux/Unix machine, you might create a subdirectory in 
your home directory called datadir and use that.
</para>
<para>
Your web-server needs read access to your datadir.  You may have to change 
the permissions of your datadir accordingly.
</para>
</sect2>

<sect2>
<title>Create a plugin Directory</title>
<para>
PyBlosxom allows you to change the default behavior by installing plugins.  
There are plugins at http://pyblosxom.sourceforge.net/ in the Plugin 
Registry.  Additionally, anyone can create plugins; they're written in 
Python and don't require any special editors or licesnes to
create.
</para>
<para>
Your web-server needs read access to your plugin directory.  You may have 
to change the permissions of your plugin directory accordingly.
</para>
</sect2>

<sect2>
<title>Configure PyBlosxom by Editing config.py</title>
<para>
The config.py file is a text file written in Python.  You can use any text editor to edit it.
It has a series of comments in it that will help guide you through setting the various properties
you need to set.
</para>
<para>
Plugins will require you to add new variables to your config.py file in order
to direct the plugin's behavior.  Additionally, you can add variables
to your config.py and these variables will be available to you in your
flavour templates.
</para>
</sect2>

<sect2>
<title>Verify Your Installation</title>
<para>
When you're done editing your config.py file, run "./pyblosxom.cgi".  This will 
verify that pyblosxom.cgi is pointing to a valid Python instance, your 
configuration is correct, and that you're datadir is there.
</para>
<para>
Then, using any text editor, create a file called firstpost.txt in your 
datadir and in that file write: 
</para>
<programlisting role="html"><![CDATA[
First Post
<p>
   This is the first post in my blog.
</p>
]]></programlisting>
<para>
The first line "First Post" becomes the title of the blog entry.  The date 
of teh blog entry is the mtime on the file.  The body of the blog entry 
starts with the HTML paragraph tag in the second line and extends to the 
end paragraph tag in the last line.  Your blog entries can be as long as 
you want.  The first line is plain text--everything after that is HTML.  
If you want to use a different markup like reST or Textile or Moinmoin or
something like that, see the chapter on entry parsers for how to set it up.
</para>
<para>
Now it's time to test your installation in a web-browser.
</para>
<para>
Assume that you're a user on a Linux machine running Apache with user 
folders set up.  Then the url for your pyblosxom instance might be 
something like this: http://www.joe.com/~joe/cgi-bin/pyblosxom.cgi .
</para>
</sect2>
</sect1>


<sect1>
<title>Setting up PyBlosxom as an ISP-like Installation</title>
<para>
This can be done (and has been done). FIXME Need instructions for it. 
</para>
</sect1>

<sect1>
<title>Using mod_python, Twisted or WSGI</title>
<para>
PyBlosxom 1.2 has preliminary support for other frameworks than CGI.  While
we think it works fine, it could use some more testing.
</para>
<para>
FIXME - need instructions for setting up with mod_python, Twisted, and WSGI.
</para>
</sect1>

</chapter>







<!--
  CHAPTER FLAVOURS
-->
<chapter>
<title>Flavours</title>
<para>
PyBlosxom uses renderers to take the data provided in the entries and 
transform it into the output.  Output can be html, xhtml, xml, or anything 
else--anything that you could get back from a CGI script or web application.  
The default renderer can be set in your config file like this:
</para>
<programlisting role="python">
py["renderer"] = "blosxom"
</programlisting>
<para>
PyBlosxom comes with two renderers: blosxom and debug.  The debug renderer
displays all the data in the various parts of the PyBlosxom Request
object.  This is really helpful to see what variables are at your disposal
and also to debug problems you might be having with plugins you've installed.
</para>
<para>
The blosxom renderer renders entries just like Blosxom does.
</para>
<para>
If you want your blog rendered using a different template system--say
Cheetah or htmltmpl--implement a renderer that does so as a PyBlosxom
plugin.  There's more on this in the chapter on writing plugins.
</para>
<para>
The rest of this chapter walks through the blosxom renderer which comes
with PyBlosxom.
</para>

<sect1>
<title>Flavours and Templates</title>
<para>
The blosxom renderer uses the same template style that Blosxom uses.  As
such, you can use most Blosxom flavour templates without too many 
modifications.
</para>
<para>
A flavour can be thought of as a theme or an output format.  For example,
you could have an HTML flavour that renders the blog data in HTML format.
You could have an XHTML flavour that renders the blog in a strict XHTML
format.  You could have a happy-sunshine flavour that renders the blog
in HTML format using a happy sunshiney look and feel.  So on and so forth.
</para>
<para>
A flavour consists of a series of templates each of which is a part of 
the page that finally gets rendered:
</para>
<itemizedlist>
<listitem><para>content_type - holds the content type of the flavour</para></listitem>
<listitem><para>head - holds everything before all the entries</para></listitem>
<listitem><para>story - holds a single entry</para></listitem>
<listitem><para>foot - holds everything after all the entries</para></listitem>
<listitem><para>date_head - shows at the start of a date (this only exists in PyBlosxom)</para></listitem>
<listitem><para>date_foot - shows at the end of a date (this only exists in PyBlosxom)</para></listitem>
</itemizedlist>
<para>
Flavour templates are stored in your datadir alongside all your entries.
</para>
<para>
Say you had an html flavour of your site.  You would have the following 
files in your datadir:
</para>
<itemizedlist>
<listitem><para>content_type.html</para></listitem>
<listitem><para>head.html</para></listitem>
<listitem><para>story.html</para></listitem>
<listitem><para>foot.html</para></listitem>
<listitem><para>date_head.html</para></listitem>
<listitem><para>date_foot.html</para></listitem>
</itemizedlist>
<para>
If you want to create a "joy" flavour, you would have the following files 
in your datadir:
</para>
<itemizedlist>
<listitem><para>content_type.joy</para></listitem>
<listitem><para>head.joy</para></listitem>
<listitem><para>story.joy</para></listitem>
<listitem><para>foot.joy</para></listitem>
<listitem><para>date_head.joy</para></listitem>
<listitem><para>date_foot.joy</para></listitem>
</itemizedlist>
<para>
You can have as many flavours as you want in your datadir.  The one thing 
to be aware of is creating a flavour where the name is the same extension 
as the file extention of your blog entries.  The default extension for 
blog entries is .txt--don't create a "txt" flavour.
</para>
<para>
PyBlosxom comes with a default html flavour.  The template code is built 
into the blosxom renderer file itself and doesn't require you to create 
or copy over any files.  However, since it's incredibly bland, most people 
either create their own flavour or use one from the flavour registry on 
http://pyblosxom.sourceforge.net/ .
</para>
</sect1>

<sect1>
<title>Template Variables</title>
<para>
Here's the variables that are available in your templates. Plugins will 
add variables. To get a complete list of what variables are available in 
'your' blog, use the debug renderer by changing the renderer property in 
your config.py file to debug like this:
</para>
<programlisting role="python">
py["renderer"] = "debug"
</programlisting>
<para>
That will tell you all kinds of stuff about the data structures involved 
in the request.
</para>

<sect2>
<title>Variables From config.py</title>
<para>
These template variables are available to all templates. They come directly 
from your config.py file.
</para>

<table>
<title>Template variables from config.py</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>blog_description</entry>
<entry>the description of the blog</entry>
<entry>blosxom with a touch of python</entry>
</row>
<row>
<entry>blog_title</entry>
<entry>the title of the blog</entry>
<entry>RoughingIT - pyblosxom : /weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>blog_language</entry>
<entry>the language of the blog</entry>
<entry>en</entry>
</row>
<row>
<entry>blog_encoding</entry>
<entry>the encoding of the blog</entry>
<entry>iso8859-1</entry>
</row>
<row>
<entry>blog_author</entry>
<entry>the author of the blog (hopefully you)</entry>
<entry>Joe Dirt</entry>
</row>
<row>
<entry>blog_email</entry>
<entry>the email address of the author of the blog (feel free to obfuscate it)</entry>
<entry>joe at joe dot com</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Additionally, any other properties you set in config.py are available 
in your templates. If you wanted to create a blog_images variable holding
the base url of the directory with all your images:
</para>
<programlisting role="python">
py["blog_images"] = "http://www.joe.com/~joe/images/"
</programlisting>
<para>
to your config.py file and it would be available in all your templates.
</para>
</sect2>

<sect2>
<title>Calculated Template Variables</title>
<para>
These template variables are available to all templates as well.  They are 
calculated based on the request.
</para>

<table>
<title>Calculated template variables</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>content_type</entry>
<entry>the content type of this page</entry>
<entry>text/html</entry>
</row>
<row>
<entry>root_datadir</entry>
<entry>the root datadir of this page?</entry>
<entry>/home/subtle/blosxom/weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>url</entry>
<entry>the PATH_INFO to this page</entry>
<entry>pyblosxom/weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>flavour</entry>
<entry>the flavour for this page</entry>
<entry>html</entry>
</row>
<row>
<entry>pi_yr</entry>
<entry>the four-digit year the user requested</entry>
<entry>2002</entry>
</row>
<row>
<entry>pi_mo</entry>
<entry>the month name the user requested</entry>
<entry>Sep</entry>
</row>
<row>
<entry>pi_da</entry>
<entry>the day number the user requested</entry>
<entry>15</entry>
</row>
<row>
<entry>pi_bl</entry>
<entry>the entry the user requested to see</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Template Variables Only Available in the story Template</title>
<para>
These template variables are only available in your story template.
</para>
<table>
<title>Variables in the story template</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>title</entry>
<entry>title of the entry</entry>
<entry>First Post!</entry>
</row>
<row>
<entry>filename</entry>
<entry>templete file name and path of the entry</entry>
<entry>/home/subtle/blosxom/weblogs/tools/pyblosxom/index.txt</entry>
</row>
<row>
<entry>file_path</entry>
<entry>just the filename and extensions of the entry</entry>
<entry>index.txt</entry>
</row>
<row>
<entry>fn</entry>
<entry>just the filename (no extension)</entry>
<entry>index</entry>
</row>
<row>
<entry>absolute_path</entry>
<entry>the category/path of the entry</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>body</entry>
<entry>the text of the entry</entry>
<entry>first post!</entry>
</row>
<row>
<entry>tb_id</entry>
<entry>the trackback id of the entry</entry>
<entry>_index</entry>
</row>
<row>
<entry>path</entry>
<entry>the category/path of the entry</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>yr</entry>
<entry>the four digit year of the mtime of this entry</entry>
<entry>2004</entry>
</row>
<row>
<entry>mo</entry>
<entry>the month abbreviation of the mtime of this entry</entry>
<entry>Jan</entry>
</row>
<row>
<entry>mo_num</entry>
<entry>the month number of the mtime of this entry</entry>
<entry>01</entry>
</row>
<row>
<entry>ti</entry>
<entry>the hour and minute of the mtime of this entry</entry>
<entry>16:40</entry>
</row>
<row>
<entry>date</entry>
<entry>the date string of the mtime of this entry</entry>
<entry>Sun, 23 May 2004</entry>
</row>
<row>
<entry>fulltime</entry>
<entry>another date string</entry>
<entry>20040523164000</entry>
</row>
<row>
<entry>timetuple</entry>
<entry>the time tuple</entry>
<entry>(2004, 5, 23, 16, 40, 0, 6, 144, 1)</entry>
</row>
<row>
<entry>mtime</entry>
<entry>seconds since the epoch</entry>
<entry>1085348400.0</entry>
</row>
<row>
<entry>dw</entry>
<entry>the day of the week</entry>
<entry>Sunday</entry>
</row>
<row>
<entry>da</entry>
<entry>the day of the month</entry>
<entry>23</entry>
</row>
<row>
<entry>w3cdate</entry>
<entry>the w3c date</entry>
<entry>2004-05-23T21:40:00Z</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2>
<title>Template Variables From Plugins</title>
<para>
Additionally, many plugins will create additional variables. Refer to the 
plugin's documentation for what variables it creates, where the variables 
are available, and what the variables do.
</para>
</sect2>
</sect1>

<sect1>
<title>Invoking a Flavour</title>
<para>
The flavour for a given page is specified in the extension of the file 
being requested. For example:
</para>

<table>
<title>Examples of request URIs</title>
<tgroup cols="2">
<thead>
<row>
<entry>url</entry>
<entry>what happens</entry>
</row>
</thead>
<tbody>
<row>
<entry>http://some.blog.org/</entry>
<entry>brings up the index in the default flavour which is "html"</entry>
</row>
<row>
<entry>http://some.blog.org/index.html</entry>
<entry>brings up the index in the "html" flavour</entry>
</row>
<row>
<entry>http://some.blog.org/index.rss</entry>
<entry>brings up the index in the "rss" flavour (which by default is RSS 0.9.1)</entry>
</row>
<row>
<entry>http://some.blog.org/2004/05/index.joy</entry>
<entry>brings up the index for May of 2004 in the "joy" flavour</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Additionally, you can specify the flavour using the flav QueryString variable. Examples:
</para>
<table>
<title>Specifying flavour using the querystring</title>
<tgroup cols="2">
<thead>
<row>
<entry>uri</entry>
<entry>what happens</entry>
</row>
</thead>
<tbody>
<row>
<entry>http://some.blog.org/</entry>
<entry>brings up the index in the default flavour which is "html"</entry>
</row>
<row>
<entry>http://some.blog.org/?flav=rss</entry>
<entry>-brings up the index in the "rss" flavour</entry>
</row>
<row>
<entry>http://some.blog.org/2004/05/index?flav=joy</entry>
<entry>brings up the index for May of 2004 in the "joy" flavour</entry>
</row>
</tbody>
</tgroup>
</table>
<para>
You can change the default flavour from "html" to some other flavour in 
your config.py file with the default_flavour property:
</para>
<programlisting role="python">
py["default_flavour"] = "joy"
</programlisting>
<para>
Doing this will set the default flavour to use when the URI the user has
used doesn't specify which flavour to use.  For example, if you do the
above, then the following URIs will use the default flavour:
</para>
<table>
<title>Default flavour used</title>
<tgroup cols="2">
<thead>
<row>
<entry>uri</entry>
<entry>what happens</entry>
</row>
</thead>
<tbody>
<row>
<entry>http://www.joe.com/cgi-bin/pyblosxom.cgi/2005/03</entry>
<entry>uses the default flavour which is set to "joy"</entry>
</row>
<row>
<entry>http://www.joe.com/cgi-bin/pyblosxom.cgi/2005/03/?flav=html</entry>
<entry>uses the html flavour as specified by flav=</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>

<sect1>
<title>Overriding Flavour Templates by Category</title>
<para>
Some folks like having certain categories of their blog have a different 
look and feel.  You can do this by placing flavour template files in that 
category directory.  For example, your directory tree may look something 
like this:
</para>
<programlisting role="filelisting">
datadir/
   |- content/
      |- content_type.html         <- 1
      |- head.html                 <- 1
      |- story.html                <- 1
      |- foot.html                 <- 1
      |- DailyAffairs/
      |- Travel/
      |- Coding/
         |- content_type.html      <- 2
         |- head.html              <- 2
         |- story.html             <- 2
         |- foot.html              <- 2
         |- Python/
         |- C/
</programlisting>
<para>
The default flavour for all your directories would be "html" and would be 
taken from the flavour marked "1".  However, if the user is looking at 
entries in the Coding category or any category under Coding, they'll see 
the "html" flavour templates marked by "2".
</para>
</sect1>

<sect1>
<title>Order of Operations to Figure Out Which Flavour to Use</title>
<para>
We know that you can specify the default flavour to use in the config.py
file with the default_flavour property.  We know that the user can specify
which flavour to use by the file extension of the URI.  We also know that
the user can specify which flavour to use by using the flav= name/value pair
in the query string.
</para>
<para>
The order in which we figure out which flavour to use is this:
</para>
<orderedlist numeration="arabic">
<listitem><para>look at the URI extenstion: if the URI has one, then we use that.</para></listitem>
<listitem><para>look at the flav= querystring variable: if there is one, then we use that.</para></listitem>
<listitem><para>look at the default_flavour property in the config.py file: if there is one, then we use that.</para></listitem>
<listitem><para>use the "html" flavour</para></listitem>
</orderedlist>
</sect1>

<sect1>
<title>Basic Set of Templates</title>
<para>
Here's a really basic set of templates for an html flavour.
</para>

<table>
<title>Basic set of templates for an html flavour</title>
<tgroup cols="2">
<thead>
<row>
<entry>template name</entry>
<entry>content</entry>
</row>
</thead>
<tbody>
<row>
<entry>content_type.html</entry>
<entry>text/html</entry>
</row>
<row>
<entry>head.html</entry>
<entry>
<programlisting role="html"><![CDATA[
<html>
<head>
  <title>$blog_title $pi_da $pi_mo $pi_yr</title>
</head>
<body>
<h1>$blog_title</h1>
<p>$pi_da $pi_mo $pi_yr</p>
]]></programlisting>
</entry>
</row>
<row>
<entry>story.html</entry>
<entry>
<programlisting role="html"><![CDATA[
<h3><a name="$fn">$title</a></h3>
<div class="blosxomStory">
$body
<p>
  posted at: $ti | 
  path: <a href="$base_url/$absolute_path" title="path">/$absolute_path</a> | 
  <a href="$base_url/$file_path.$flavour">permalink</a>
</p>
</div>
]]></programlisting>
</entry>
</row>
<row>
<entry>foot.html</entry>
<entry>
<programlisting role="html"><![CDATA[
<p>
  Made with PyBlosxom
</p>
</body>
</html>
]]></programlisting>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>
</chapter>






<!--
  CHAPTER PLUGINS
-->

<chapter id="plugins">
<title>Plugins</title>
<para>
PyBlosxom allows you to extend and augment its base functionality using 
PyBlosxom plugins.  Plugins allow you to create additional variables; provide
additional entry parsers, renderers, post-formatters, and pre-formatters;
create new output data types; pull information from other non-blog sources;
create images; and a variety of other things.
</para>

<sect1>
<title>Setting PyBloxsom up to Use Plugins</title>
<para>
There are two properties in your config.py file that affect the behavior 
for loading plugins.
</para>
<para>
The first one is the plugin_dirs property which is a list of strings 
specifying all the directories you might have plugins. For example:
</para>
<programlisting role="python">
py["plugin_dirs"] = ["/home/will/pybloxsom/plugins"]
</programlisting>

<para>
This will cause PyBlosxom to look in this specific directory for plugins.
</para>

<para>
The other property is the load_plugins property. If you don't have this set 
at all (i.e. it's either not in the config.py file or the line is commented
out), PyBlosxom will load all plugins it finds in the plugin directories 
you've specified and load them. It will look in each directory in order as 
you've specified. It will load the plugins in each directory in alphabetical 
order by filename.
</para>

<para>
The other way to load plugins is by specifying the plugins explicitly by 
setting the load_plugins property.  PyBlosxom will load only the plugins 
you've specified and will load them in the order you've specified.  The 
load_plugins property takes a list of strings. For example:
</para>

<programlisting role="python">
py["load_plugins"] = ["calendar", "category", "booklist"]
</programlisting>

<para>
This will load the plugins whose filenames are "calendar.py", "category.py", 
and "booklist.py". It will only load those plugins even if other plugins are 
in the directory and it will load them in that order.
</para>
</sect1>

<sect1>
<title>Finding Plugins</title>
<para>
You can find plugins in the plugin registry at 
http://pyblosxom.sourceforge.net/ .
</para>
<para>
Additionally, some people write plugins, but never register with the plugin 
registry. Sometimes this is because the author doesn't feel the plugin is 
finished for public consumption. Even so, it might meet your needs. The best 
way to find these plugins is to ask on the pyblosxom-users mailing list for 
a plugin that has the functionality you desire.
</para>
</sect1>

<sect1>
<title>Installing Plugins</title>
<para>
When you're installing a plugin, refer to its documentation. The documentation 
could be in a README file, but more likely it's in the plugin code itself at 
the top of the file. This documentation should tell you how to install the 
plugin, what template variables the plugin exposes, how to invoke the plugin, 
how to get in touch with the author should you find bugs or need help, and 
any additional things you should know about.
</para>
<para>
Most plugins should have a pretty easy installation method. You should be 
able to copy the plugin into the directory defined in your config.py file 
in the plugin_dirs property. Then there might be some additional properties 
you'll ahve to set in your config.py file to define the plugin's behavior. 
That should be about it.  On some occasions, you may have to change the code 
in the plugin itself to meet your specific needs.
</para>
</sect1>

<sect1>
<title>Writing Your Own Plugins</title>
<para>
You may find that you desire functionality and there is no plugin that anyone 
knows about that performs that functionality. It's probably best at this 
point for you to either pay someone to write the plugin you need or write 
it yourself.
</para>
<para>
Plugins are pretty easy to write and can cover a lot of really different 
functionality. The best way to learn how to write PyBlosxom plugins is to 
read through the plugins in the plugin registry. Many of them are well 
written and may provide insight as to how to solve your specific problem.
</para>
<para>
Additionally, feel free to ask for help on the pyblosxom-users and 
pyblosxom-devel mailing lists. 
</para>
</sect1>
</chapter>





<!--
  ENTRY PARSERS
-->
<chapter id="entryparsers">
<title>Entry Parsers</title>
<para>
PyBlosxom supports only one format for entry files by default.  This format
is the same format that blosxom uses.  The extension for this format is 
".txt".  The first line of the file is in plain text and forms the title
of the entry.  The second line through the end of the file is in HTML and 
is the body of the entry.
</para>
<para>
A sample blog entry could look like this:
</para>
<programlisting role="text"><![CDATA[
First post
<p>
  Here's the body of my first post.
</p>
]]></programlisting>

<para>
Some people really detest writing in HTML which is valid.  Other 
people use their entries in other places, so they need a markup format 
that's less web-oriented.  Some folks write a lot of material in a non-HTML 
markup format and would like to use that same format for blog entries.  
These are all very valid reasons to want to use other markup formats.
</para>
<para>
PyBlosxom allows you to install entry parser plugins which are PyBlosxom 
plugins that implement an entry parser.  These entry parser plugins allow 
you to use other markup formats.  Check the Plugin Registry at 
http://pyblosxom.sourceforge.net/ for which entry parsers are available.
</para>
<para>
In general, we only have entry parsers written by people who really 
wanted that markup format.  If you don't see your favorite markup format 
represented, try looking at the code for other entry parsers and implement 
it yourself.  If you need help, talk to us on the pyblosxom-users or 
pyblosxom-devel mailing lists.
</para>
<para>
Details on the various entry parsers should be at the top of the entry
parser plugin itself in the Python doc-string.
</para>
</chapter>







<!--
  WRITING ENTRIES
-->
<chapter id="writingentries">
<title>Writing Entries</title>
<sect1>
<title>Categories</title>
<para>
Writing entries in PyBlosxom is fairly straightforward.  Each entry
is a single text file located somewhere in the directory tree of your
datadir.  The directory that the entry is in is the category the entry
is "filed under".  For example, if my datadir was "/home/joe/datadir"
and I stored an entry named "firstpost.txt" in /home/joe/datadir/content"
then the category for my entry would be "/content".
</para>
<para>
Be careful when you create your categories--be sure to use characters
that are appropriate in directory names in the file system.
</para>
<para>
Don't worry about making sure you have all the categories you need up
front--you can add them as you need them.
</para>
</sect1>

<sect1>
<title>The Format of an Entry</title>
<para>
PyBlosxom entries consist of three parts: the title, the metadata, and
then the body of the entry.  The first line is title of the entry.  Then
comes the metadata of the entry (if any).  After the metadata comes the
body of the entry.
</para>
<para>
The title consists of a single line of plain text.  You can have whatever
characters you like in the title of your entry.  The title doesn't have
to be the same as the entry file name.
</para>
<para>
The metadata section is between the title line and the body of the entry.
It consists of a series of lines that start with the hash mark (#), then
a metadata variable name, then the metadata variable value.
</para>
<para>
Metadata is useful for some situations.  Unfortunately, you cannot store
the mtime of your blog entry in the metadata of the entry itself.  The
problem here is that we don't open up every entry file when figuring out
what to display and we'll only be able to see the metadata if we've opened
the file and parsed it.
</para>
<para>
The body of the entry is written in HTML and comprises the rest of the
entry file.
</para>
<para>
Here's an example first post entry:
</para>
<programlisting role="html"><![CDATA[
This is my first post!
<p>
  This is the body of the first post to my blog.
</p>
]]></programlisting>
<para>
Here's a more complex example:
</para>
<programlisting role="html"><![CDATA[
The rain in Spain....
<p>
  The rain
</p>
<p align="center">
  in Spain
</p>
<p align="right">
  is <font color="ff0000">mainly</font> on the plain.
</p>
]]></programlisting>
<para>
Here's an example of a post with metadata:
</para>
<programlisting role="html"><![CDATA[
The rain in Spain....
#mood bored
#music The Doors
<p>
  The rain
</p>
<p align="center">
  in Spain
</p>
<p align="right">
  is <font color="ff0000">mainly</font> on the plain.
</p>
]]></programlisting>
<para>
The metadata variables here would be avilable in your story template.  So for the
above example, the template variable $mood would be filled in with "bored" and
$music would be filled in with "The Doors".
</para>
</sect1>

<sect1>
<title>Posting Date</title>
<para>
The posting date of the entry file is the modification time (also known as
mtime) on the file itself as stored by your file system.  Every time you 
go to edit an entry, it changes the modification time.  You can see this
in the following example of output:
</para>
<programlisting role="shell"><![CDATA[
willg ~/blogdata/blosxom/site: vi testpost.txt                            [1]
willg ~/blogdata/blosxom/site: ls -l
total 16
-rw-r--r--  1 willg willg 764 Jul 20  2003 minoradjustments.txt
-rw-r--r--  1 willg willg 524 Jul 24  2003 moreminoradjustments.txt
-rw-r--r--  1 willg willg 284 Aug 15  2004 nomorecalendar.txt
-rw-r--r--  1 willg willg  59 Mar 21 16:30 testpost.txt                   [2]
willg ~/blogdata/blosxom/site: vi testpost.txt                            [3]
willg ~/blogdata/blosxom/site: ls -l
total 16
-rw-r--r--  1 willg willg 764 Jul 20  2003 minoradjustments.txt
-rw-r--r--  1 willg willg 524 Jul 24  2003 moreminoradjustments.txt
-rw-r--r--  1 willg willg 284 Aug 15  2004 nomorecalendar.txt
-rw-r--r--  1 willg willg  59 Mar 21 16:34 testpost.txt                   [4]
]]></programlisting>
<para>
[1] I create the blog entry "testpost.txt" using vi (a text editor).  The
mtime of the file will be the time I last save the file and exit out of
vi.
</para>
<para>
[2] See the mtime on the file is Mar 21 16:30.  That's when I last saved
the blog entry and exited out of vi.
</para>
<para>
[3] I discover that I made a spelling mistake in my entry...  So I edit
it again in vi and fix the mistake.  The mtime of the entry has now changed...
</para>
<para>
[4] Now the mtime of the file is Mar 21 16:34.  This is the time that
will show up in my blog as the posting date.
</para>
<para>
There are some issues with this method for storing the posting date.  First,
if you ever change the blog entry, the mtime will change as well.  That
makes updating blog entries very difficult down the line.  There's a utility
that comes with the contributed plugins pack called "editfile.py".  This
will note the mtime of the file, open up your favorite editor to edit the
file, and when you're done, it'll reset the mtime of the file back to what
it was.
</para>
</sect1>

<sect1>
<title>Beyond Editors</title>
<para>
There's no reason that all your entries have to come from editing blog entry
text files in your datadir.  You could rig up procmail to look for emails
that meet a certain description and convert those emails into blog entries.
</para>

<sect2>
<title>Using w.bloggar</title>
<para>
PyBlosxom works with w.bloggar (http://www.wbloggar.com/).  In order to use w.bloggar
you have to do the following:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
  install the xmlrpc plugin found at http://pyblosxom.sourceforge.net/ in the
  plugin registry
</para>
</listitem>
<listitem>
<para>
  install the xmlrpc_bloggar plugin found at http://pyblosxom.sourceforge.net/ in the
  plugin registry
</para>
</listitem>
<listitem>
<para>
  in the Content Management System section of the w.bloggar account settings 
  dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Blog Tool" to "Custom"</para></listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  in the API Server tab section of the w.bloggar account settings dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Host" to the name of your server</para></listitem>
  <listitem>
    <para>"Page" to the url of your blog with /RPC at the end--
    For example, mine might be "/~joe/cgi-bin/pyblosxom.cgi/RPC"</para>
  </listitem>
</itemizedlist> 
</listitem>
<listitem>
<para>
  in the Custom tab section of the w.bloggar account settings dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Posts" to "Blogger API"</para></listitem>
  <listitem><para>"Categories" to "Not supported"</para></listitem>
  <listitem><para>"Templates" to "Not supported"</para></listitem>
  <listitem><para>"Title Tags" should be blank</para></listitem>
  <listitem><para>"Category Tags" should be blank</para></listitem>
</itemizedlist>
</listitem>
</orderedlist>
<para>
When you go to write a new entry, leave the title field blank and do your entire 
post in the data section with the first line being the title (just like blosxom 
entries).
</para>
<para>
One thing you should note is that pyblosxom will take the first line and use that 
to generate the file name of the entry. So if the title of the entry is "How to 
use w.bloggar with pyblosxom", the file name ends up being 
"How_to_use_w_bloggar_with_pyblosxom.txt" which is a little annoying but whatever.
</para>
<para>
FIXME - Does this still work?
</para>
</sect2>

<sect2>
<title>Using Ecto</title>
<para>
FIXME - I need instructions for this
</para>
</sect2>

<sect2>
<title>Other blog tools?</title>
<para>
Does PyBlosxom work with other blog tools?
</para>
</sect2>

</sect1>
</chapter>






<!--
  CHAPTER STATIC RENDERING
-->

<chapter id="staticrendering">
<title>Static Rendering</title>
<para>
Static rendering made its first appearance in PyBlosxom 1.0. It fills the 
functionality gap for people who want to use PyBlosxom, but don't have a 
web-server with CGI installed, don't have CGI access, or can't run PyBlosxom 
for one of a myriad of other reasons. Static rendering allows these people 
to run PyBlosxom on their local machine, write blog entries, render their 
entire site into HTML, and then use ftp or some other file copy method to 
move the pages up to their static web-site.
</para>
<para>
PyBlosxom's static rendering allows for incremental building.  It can scan 
your entries, figure out what's changed, and render only the pages that 
need re-rendering.
</para>
<para>
Beyond that, it's not particularly sophisticated.
</para>

<sect1>
<title>Configuring Static Rendering</title>
<para>
These are the instructions for configuring static rendering in PyBlosxom.
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
Install PyBlosxom. When you're copying the pyblosxom.cgi and config.py 
files, you don't have to put them in a CGI directory--you can put them 
in any directory you have permissions in. For example, I created a directory 
/home/joe/pyblosxom/ and put both files in there.
</para>
</listitem>
<listitem>
<para>
Add static_dir to your config.py file. This is the directory we will save 
all the static output. The value of static_dir should be a string representing 
the absolute path of the output directory for static rendering.
</para>
</listitem>
<listitem>
<para>
Add static_flavours to your config.py file. The value of static_flavours 
should be a list of strings representing all the flavours that should be 
rendered. This defaults to [ "html" ].
</para>
</listitem>
<listitem>
<para>
Add static_monthnames to your config.py file. The value (either 1 or 0) 
will determine if you want month names (such as April) in the static pages. 
On some versions of Pyblosxom, month names are not supported, and you will 
need to use month numbers.
</para>
</listitem>
<listitem>
<para>
Add static_monthnumbers to your config.py file. The value (either 1 or 0) 
will determine if you want month numbers (such as 04 for April) in the 
static pages.
</para>
</listitem>
<listitem>
<para>
Set base_url in your config.py file to the base url your blog will have. 
For example, if your static_dir were set to /home/joe/public_html and the 
url for that directory were http://www.joe.com/~joe/ , then you probably 
want your base_url to be http://www.joe.com/~joe/ . 
</para>
</listitem>
</orderedlist>
</sect1>

<sect1>
<title>Running Static Rendering</title>

<sect2>
<title>Render Everything</title>
<para>
Now you can run static rendering:
</para>
<programlisting role="shell">
% cd directory-with-pyblosxom.cgi-in-it 
% ./pyblosxom.cgi --static 
</programlisting>
<para>
Lots of output will appear as it figures out all the urls that need to 
be rendered and then renders them all one by one.
</para>
</sect2>

<sect2>
<title>Incremental Rendering</title>
<para>
We have incremental rendering which will go find all the entries that have 
changed since we rendered them and then re-render them. It does this by 
comparing the mtime on the entry file with the mtime on the rendererd file.
</para>
<para>
It works like this:
</para>
<programlisting role="shell">
% cd directory-with-pyblosxom.cgi-in-it 
% ./pyblosxom.cgi --static --incremental 
</programlisting>
</sect2>
</sect1>

<sect1>
<title>Rendering Other URIs</title>
<para>
Some plugins provide other URIs that are part of your site, but not 
really part of your blog since they're not related to entries. Examples 
of this include the plugininfo plugin which provides information about 
the plugins that you're running. You can set the static_urls property 
in config.py to a list of all the urls that need to be rendered every time. 
This list could include:
</para>

<itemizedlist>
<listitem><para>RSS, FOAF, OPML, ATOM or any other kind of feeds</para></listitem>
<listitem><para>urls for plugins that aren't related to entries (plugininfo, pystaticfile, booklist, ...)</para></listitem>
</itemizedlist>

<para>
static_urls takes a list of strings where each string is a url to be 
rendered. For example if I wanted to render the booklist page and the 
RSS feed for my main page, I would set it like this:
</para>

<programlisting role="python">
py["static_urls"] = ["/booklist/index.html", "/index.xml"]
</programlisting>
</sect1>

<sect1>
<title>Additional Thoughts</title>
<para>
Static rendering is pretty simplistic. We use the tools.render_url function 
to render each url. Plugins that need to re-render the entry pages because 
something has changed (e.g. comments, pingbacks, ...), should call this 
function.
</para>
<para>
If you want to statically render your blog every night, you could write 
a shell script like this:
</para>
<programlisting role="shell">
#!/bin/bash 
 
cd directory-with-pyblosxom.cgi
./pyblosxom.cgi --static 
find static_dir-directory -mmin +30 -exec 'rm' '{}' ';' 
</programlisting>
<para>
That'll re-render everything, then delete any files in your static 
dir that are older than 30 minutes (in case you moved entries from 
one category to another or deleted an entry or whatever). 
</para>
<para>
If your web-site requires more files than just the ones that are rendered by 
PyBlosxom (images, CSS, ...), then you should copy those over with your 
shell script as well.
</para>
</sect1>
</chapter>





<!--
  CHAPTER SYNDICATION
-->

<chapter id="syndication">
<title>Syndication</title>

<sect1>
<title>RSS</title>
<para>
PyBlosxom comes with an rss flavour that produces RSS 0.9.1 output.
</para>
<para>
FIXME - Talk about setting up the RSS 0.9.1 flavour
</para>
<para>
There is an rss2renderer plugin in the plugin registry that produces 
RSS 2.0 output.
</para>
</sect1>

<sect1>
<title>Atom</title>
<para>
FIXME - talk about setting up the rss2renderer
</para>
</sect1>

<sect1>
<title>Other Formats</title>
<para>
FIXME - Other formats? 
</para>
</sect1>
</chapter>






<!--
  CHAPTER ARCHITECTURE
-->

<chapter>
<title>PyBlosxom Architecture</title>
<para>
The architecture for PyBlosxom has evolved over time. The mission is to 
build an easily augmented blog server that uses the file system for data 
storage. Using the file system allows PyBlosxom to fit in with other 
applications rather than forcing PyBlosxom to solve all problems all by 
itself.
</para>

<sect1>
<title>Parts</title>
<para>
PyBlosxom is composed of a few different parts:
</para>
<itemizedlist>
<listitem>
<para>
pyblosxom.cgi - This is the CGI script that is executed by your web-server, 
pulls in configuration variables from config.py and then instantiates 
PyBlosxom objects to handle the request.
</para>
</listitem>
<listitem>
<para>
the Pyblosxom package - This is the Python package that holds the PyBlosxom 
objects and utility functions that handle the request.
</para>
<itemizedlist>
   <listitem>
   <para>
   the entries package - Handles the abstraction allowing PyBlosxom to use 
   entries other than those solely found on the file system.
   </para>
   </listitem>
   <listitem>
   <para>
   the renderers package - PyBlosxom can handle different renderers. The 
   renderer gets a list of entries to be rendered and can render them using 
   whatever means it so desires: blosxom templates, htmltmpl templates, 
   Cheetah templates, hard-coded RSS 2.0 markup, ...
   </para>
   </listitem>
   <listitem>
   <para>
   the cache package - PyBlosxom allows for entry-level caching. This helps 
   in cases where your entries are stored in a format that requires a lot 
   of processing to convert to HTML. 
   </para>
   </listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
PyBlosxom's look'n'feel and behavior is then augmented by:
</para>

<itemizedlist>
<listitem>
<para>
plugins - Plugins allow you to augment PyBlosxom's default behavior. These 
you can get from the plugin registry or write yourself.
</para>
</listitem>
<listitem>
<para>
flavour templates - Flavour templates allow you to create the look and feel 
of your blog. These you can get from the flavour registry or write yourself. 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1>
<title>Lifecycle of a PyBlosxom Request</title>
<para>
This is the life cycle of a single PyBlosxom request. It involves the 
following "entities":
</para>
<itemizedlist>
<listitem>
<para>
pyblosxom.cgi - A script found in the web/ directory. This is the CGI 
script that handles PyBlosxom requests.
</para>
</listitem>
<listitem>
<para>
config.py - The configuration file that defines the behavior and properties 
of your blog.
</para>
</listitem>
<listitem>
<para>
PyBlosxom.pyblosxom - The pyblosxom module holds the default PyBlosxom 
behavior functions. It also defines the Request class and the PyBlosxom class.
</para>
</listitem>
<listitem>
<para>
Pyblosxom.pyblosxom.Request - The Request object holds the state of the 
PyBlosxom request at any given time throughout the lifecycle fo the request. 
The Request is passed to most callbacks in the args dict as "request".
</para>
</listitem>
<listitem>
<para>
Pyblosxom.pyblosxom.PyBlosxom - The PyBlosxom object holds a list of 
registered plugins, what callbacks they're registered to, and the methods 
that handle the the actual request. 
</para>
</listitem>
</itemizedlist>

<para>
The PyBlosxom request lifecycle starts with the web-server executing 
pyblosxom.cgi.
</para>
<programlisting role="lifecycle">

1. pyblosxom.cgi: loads config.py
2. pyblosxom.cgi: instantiates a Request object
3. pyblosxom.cgi: instantiates a PyBlosxom object passing it the Request object
4. pyblosxom.cgi: calls run() on the PyBlosxom instance
      1. PyBlosxom instance, run method: calls initialize
            1. PyBlosxom instance, initialize method: imports the plugins
            2. PyBlosxom instance, initialize method: calls the entryparser callback to get a map of all the entry types we can handle 
      2. PyBlosxom instance, run method: calls the start callback to allow plugins to do any intialization they need to do
      3. PyBlosxom instance, run method: calls the handle callback allowing plugins to fully handle the request.
         If a plugin handles the request, the plugin should return a 1 signifying it has done so. At that point, PyBlosxom will stop trying to find a plugin to handle the request.
         If no plugin handles the request, then PyBlosxom will handle the request using the blosxom_handler PyBlosxom will handle the request using the blosxom_handler.
      4. PyBlosxom instance, run method: calls the end callback to allow plugins to do any cleanup they need to do 
</programlisting>
</sect1>

<sect1>
<title>Lifecycle of the blosxom_handler</title>
<para>
This describes what the blosxom_handler does. This is the default handler 
for PyBlosxom. It's called by the PyBlosxom instance in the run method if 
none of the plugins have handled the request already.
</para>
<programlisting role="lifecycle">
1. calls the renderer callback to get a renderer instance
   If none of the plugins return a renderer instance, then we go check to see if config.py has the renderer property set and use that.
   If there is no renderer property set, we use the blosxom renderer which is found in the pyblosxom.PyBlosxom.renderer package.
2. calls the pathinfo callback which allows all the plugins to help figure out what to do with the HTTP URI/QUERYSTRING we've been given
3. calls the filelist callback which returns a list of entries to render based on what the path info is
4. calls the prepare callback which allows plugins to transform the entries and any other data in the Request object prior to rendering
5. renders the entries 
</programlisting>
</sect1>

<sect1>
<title>Lifecycle of the blosxom Renderer</title>
<para>
The blosxom renderer renders the entries in a similar fashion to what 
Blosxom does. The blosxom renderer uses flavour templates and template 
variables. It also has a series of callbacks allowing plugins to modify 
templates and entry data at the time of rendering that specific piece.
</para>
<programlisting role="lifecycle">
1. renders the content_type template
2. calls the head callback and renders the head template
3. calls the date_head callback and renders the date_head template
4. for each story:
      1. if the mtime on this entry is different than the last entry, it calls the date_foot callback, renders the date_foot template, calls the date_head callback and renders the date_head template
      2. calls the story callback and renders the story template 
5. calls the date_foot callback and renders the date_foot template
6. renders the foot template (calls the foot callback 
</programlisting>
</sect1>

<sect1>
<title>Callbacks</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Entry Parsers</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Pre-formatters and Post-formatters</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Renderers</title>
<para>
FIXME 
</para>
</sect1>
</chapter>

<appendix>
<title>config.py variables</title>
<para>
Here is a non-comprehensive list of configuration variables:
</para>

<table>
<title>Configuration variables</title>
<tgroup cols="4">
<thead>
<row>
<entry>variable</entry>
<entry>required</entry>
<entry>data type</entry>
<entry>description</entry>
</row>
</thead>
<tbody>
<row>
<entry>blog_title</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  the title of your blog
  </para>
  <programlisting role="python">
py["blog_title"] = "Will's Blog of Awesome Stuff"
  </programlisting>
</entry>
</row>
<row>
<entry>blog_description</entry>
<entry>no</entry>
<entry>string</entry>
<entry>
  <para>
  the description of your blog
  </para>
  <programlisting role="python">
py["blog_description"] = "Blog of thoughts, comments, code examples, and such."
  </programlisting>
</entry>
</row>
<row>
<entry>blog_author</entry>
<entry>no</entry>
<entry>string</entry>
<entry>
  <para>
  this is you--your name.
  </para>
  <programlisting role="python"><![CDATA[
py["blog_author"] = "Will <will at blah dot org>"
]]></programlisting>
</entry>
</row>
<row>
<entry>blog_language</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the primary language code of your blog.
  </para>
  <programlisting role="python">
py["blog_language"] = "en"
  </programlisting>
</entry>
</row>
<row>
<entry>blog_encoding</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the encoding of your blog. iso-8859-1, utf-8, ...
  </para>
  <programlisting role="python">
py["blog_encoding"] = "iso-8859-1"
  </programlisting>
</entry>
</row>
<row>
<entry>datadir</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the full path to where your PyBlosxom entries are kept.
  </para>
  <programlisting role="python">
py["datadir"] = "/home/will/blog/datadir/"
  </programlisting>
</entry>
</row>
<row>
<entry>logdir</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the full path to the directory for logs.
  </para>
  <programlisting role="python">
py["logdir"] = "/home/will/blog/logs/"
  </programlisting>
</entry>
</row>
<row>
<entry>num_entries</entry>
<entry>no</entry>
<entry>int</entry>
<entry>
  <para>
  how many entries should show up on a given page? This defaults to 0 which will show all entries.
  </para>
  <programlisting role="python">
py["num_entries"] = 20
  </programlisting>
</entry>
</row>
<row>
<entry>plugin_dirs</entry>
<entry>no</entry>
<entry>list of strings</entry>
<entry>
  <para>
  the list of directories your plugins are stored in.
  </para>
  <programlisting role="python">
py["plugin_dirs"] = ["/home/will/pyblosxom/plugins/"]
  </programlisting>
</entry>
</row>
<row>
<entry>load_plugins</entry>
<entry>no</entry>
<entry>list of strings</entry>
<entry>
  <para>
  if this is not set, then PyBlosxom will load all the plugins in the plugin dirs you specified in alphabetical order. If this is set, then PyBlosxom will only load the plugins specified.
  </para>
  <programlisting role="python">
py["load_plugins"] = ["pycalendar", "rss2renderer"]
  </programlisting>
</entry>
</row>
</tbody>
</tgroup>
</table>
</appendix>





<appendix>
<title>GNU Free Documentation License</title>
<programlisting role="gnufdl"><![CDATA[
GNU Free Documentation License

$Revision$

$Date$

Version 1.1, March 2000

    Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place, Suite 330, 
Boston, MA 02111-1307 USA Everyone is permitted to copy and distribute verbatim 
copies of this license document, but changing it is not allowed.

PREAMBLE

The purpose of this License is to make a manual, textbook, or other written 
document "free" in the sense of freedom: to assure everyone the effective freedom 
to copy and redistribute it, with or without modifying it, either commercially or 
noncommercially. Secondarily, this License preserves for the author and publisher 
a way to get credit for their work, while not being considered responsible for 
modifications made by others.

This License is a kind of "copyleft", which means that derivative works of the 
document must themselves be free in the same sense. It complements the GNU General 
Public License, which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software, 
because free software needs free documentation: a free program should come with 
manuals providing the same freedoms that the software does. But this License is 
not limited to software manuals; it can be used for any textual work, regardless 
of subject matter or whether it is published as a printed book. We recommend this 
License principally for works whose purpose is instruction or reference.

APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work that contains a notice placed by 
the copyright holder saying it can be distributed under the terms of this License. 
The "Document", below, refers to any such manual or work. Any member of the public 
is a licensee, and is addressed as "you".

A "Modified Version" of the Document means any work containing the Document or
a portion of it, either copied verbatim, or with modifications and/or
translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of the
Document that deals exclusively with the relationship of the publishers or
authors of the Document to the Document's overall subject (or to related
matters) and contains nothing that could fall directly within that overall
subject. (For example, if the Document is in part a textbook of mathematics, a
Secondary Section may not explain any mathematics.) The relationship could be a
matter of historical connection with the subject or with related matters, or of
legal, commercial, philosophical, ethical or political position regarding them.

The "Invariant Sections" are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says that
the Document is released under this License.

The "Cover Texts" are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the
Document is released under this License.

A "Transparent" copy of the Document means a machine-readable copy, represented
in a format whose specification is available to the general public, whose
contents can be viewed and edited directly and straightforwardly with generic
text editors or (for images composed of pixels) generic paint programs or (for
drawings) some widely available drawing editor, and that is suitable for input
to text formatters or for automatic translation to a variety of formats
suitable for input to text formatters. A copy made in an otherwise Transparent
file format whose markup has been designed to thwart or discourage subsequent
modification by readers is not Transparent. A copy that is not "Transparent" is
called "Opaque".

Examples of suitable formats for Transparent copies include plain ASCII without
markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly
available DTD, and standard-conforming simple HTML designed for human
modification.  Opaque formats include PostScript, PDF, proprietary formats that
can be read and edited only by proprietary word processors, SGML or XML for
which the DTD and/or processing tools are not generally available, and the
machine-generated HTML produced by some word processors for output purposes
only.

The "Title Page" means, for a printed book, the title page itself, plus such
following pages as are needed to hold, legibly, the material this License
requires to appear in the title page. For works in formats which do not have
any title page as such, "Title Page" means the text near the most prominent
appearance of the work's title, preceding the beginning of the body of the
text.

VERBATIM COPYING

You may copy and distribute the Document in any medium, either commercially or
noncommercially, provided that this License, the copyright notices, and the
license notice saying this License applies to the Document are reproduced in
all copies, and that you add no other conditions whatsoever to those of this
License. You may not use technical measures to obstruct or control the reading
or further copying of the copies you make or distribute. However, you may
accept compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may
publicly display copies.

COPYING IN QUANTITY

If you publish printed copies of the Document numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the copies in
covers that carry, clearly and legibly, all these Cover Texts: Front-Cover
Texts on the front cover, and Back-Cover Texts on the back cover. Both covers
must also clearly and legibly identify you as the publisher of these copies.
The front cover must present the full title with all words of the title equally
prominent and visible. You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve the title
of the Document and satisfy these conditions, can be treated as verbatim
copying in other respects.

If the required texts for either cover are too voluminous to fit legibly, you
should put the first ones listed (as many as fit reasonably) on the actual
cover, and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than
100, you must either include a machine-readable Transparent copy along with
each Opaque copy, or state in or with each Opaque copy a publicly-accessible
computer-network location containing a complete Transparent copy of the
Document, free of added material, which the general network-using public has
access to download anonymously at no charge using public-standard network
protocols. If you use the latter option, you must take reasonably prudent
steps, when you begin distribution of Opaque copies in quantity, to ensure that
this Transparent copy will remain thus accessible at the stated location until
at least one year after the last time you distribute an Opaque copy (directly
or through your agents or retailers) of that edition to the public.

It is requested, but not required, that you contact the authors of the Document
well before redistributing any large number of copies, to give them a chance to
provide you with an updated version of the Document.

MODIFICATIONS

You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the Modified
Version under precisely this License, with the Modified Version filling the
role of the Document, thus licensing distribution and modification of the
Modified Version to whoever possesses a copy of it. In addition, you must do
these things in the Modified Version:

   1.

      Use in the Title Page (and on the covers, if any) a title distinct from
that of the Document, and from those of previous versions (which should, if
there were any, be listed in the History section of the Document). You may use
the same title as a previous version if the original publisher of that version
gives permission.

   2.

      List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified Version,
together with at least five of the principal authors of the Document (all of
its principal authors, if it has less than five).

   3.

      State on the Title page the name of the publisher of the Modified
Version, as the publisher.

   4.

      Preserve all the copyright notices of the Document.

   5.

      Add an appropriate copyright notice for your modifications adjacent to
the other copyright notices.

   6.

      Include, immediately after the copyright notices, a license notice giving
the public permission to use the Modified Version under the terms of this
License, in the form shown in the Addendum below.

   7.

      Preserve in that license notice the full lists of Invariant Sections and
required Cover Texts given in the Document's license notice.

   8.

Include an unaltered copy of this License.

   9.

      Preserve the section entitled "History", and its title, and add to it an
item stating at least the title, year, new authors, and publisher of the
Modified Version as given on the Title Page. If there is no section entitled
"History" in the Document, create one stating the title, year, authors, and
publisher of the Document as given on its Title Page, then add an item
describing the Modified Version as stated in the previous sentence.

  10.

      Preserve the network location, if any, given in the Document for public
access to a Transparent copy of the Document, and likewise the network
locations given in the Document for previous versions it was based on. These
may be placed in the "History" section. You may omit a network location for a
work that was published at least four years before the Document itself, or if
the original publisher of the version it refers to gives permission.

  11.

      In any section entitled "Acknowledgements" or "Dedications", preserve the
section's title, and preserve in the section all the substance and tone of each
of the contributor acknowledgements and/or dedications given therein.

  12.

      Preserve all the Invariant Sections of the Document, unaltered in their
text and in their titles. Section numbers or the equivalent are not considered
part of the section titles.

  13.

      Delete any section entitled "Endorsements". Such a section may not be
included in the Modified Version.

  14.

      Do not retitle any existing section as "Endorsements" or to conflict in
title with any Invariant Section.

If the Modified Version includes new front-matter sections or appendices that
qualify as Secondary Sections and contain no material copied from the Document,
you may at your option designate some or all of these sections as invariant. To
do this, add their titles to the list of Invariant Sections in the Modified
Version's license notice. These titles must be distinct from any other section
titles.

You may add a section entitled "Endorsements", provided it contains nothing but
endorsements of your Modified Version by various parties--for example,
statements of peer review or that the text has been approved by an organization
as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a passage
of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts
in the Modified Version. Only one passage of Front-Cover Text and one of
Back-Cover Text may be added by (or through arrangements made by) any one
entity. If the Document already includes a cover text for the same cover,
previously added by you or by arrangement made by the same entity you are
acting on behalf of, you may not add another; but you may replace the old one,
on explicit permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License give
permission to use their names for publicity for or to assert or imply
endorsement of any Modified Version.

COMBINING DOCUMENTS

You may combine the Document with other documents released under this License,
under the terms defined in section 4 above for modified versions, provided that
you include in the combination all of the Invariant Sections of all of the
original documents, unmodified, and list them all as Invariant Sections of your
combined work in its license notice.

The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there are
multiple Invariant Sections with the same name but different contents, make the
title of each such section unique by adding at the end of it, in parentheses,
the name of the original author or publisher of that section if known, or else
a unique number. Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections entitled "History" in the 
various original documents, forming one section entitled "History"; likewise 
combine any sections entitled "Acknowledgements", and any sections entitled 
"Dedications". You must delete all sections entitled "Endorsements."

COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents released 
under this License, and replace the individual copies of this License in the 
various documents with a single copy that is included in the collection, provided 
that you follow the rules of this License for verbatim copying of each of the 
documents in all other respects.

You may extract a single document from such a collection, and distribute it
individually under this License, provided you insert a copy of this License
into the extracted document, and follow this License in all other respects
regarding verbatim copying of that document.

AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or distribution
medium, does not as a whole count as a Modified Version of the Document,
provided no compilation copyright is claimed for the compilation. Such a
compilation is called an "aggregate", and this License does not apply to the
other self-contained works thus compiled with the Document, on account of their
being thus compiled, if they are not themselves derivative works of the
Document.

If the Cover Text requirement of section 3 is applicable to these copies of the
Document, then if the Document is less than one quarter of the entire
aggregate, the Document's Cover Texts may be placed on covers that surround
only the Document within the aggregate. Otherwise they must appear on covers
around the whole aggregate.

TRANSLATION

Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4. Replacing Invariant
Sections with translations requires special permission from their copyright
holders, but you may include translations of some or all Invariant Sections in
addition to the original versions of these Invariant Sections. You may include
a translation of this License provided that you also include the original
English version of this License. In case of a disagreement between the
translation and the original English version of this License, the original
English version will prevail.

TERMINATION

You may not copy, modify, sublicense, or distribute the Document except as
expressly provided for under this License. Any other attempt to copy, modify,
sublicense or distribute the Document is void, and will automatically terminate
your rights under this License. However, parties who have received copies, or
rights, from you under this License will not have their licenses terminated so
long as such parties remain in full compliance.

FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the GNU Free
Documentation License from time to time. Such new versions will be similar in
spirit to the present version, but may differ in detail to address new problems
or concerns. See http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number. If the
Document specifies that a particular numbered version of this License "or any
later version" applies to it, you have the option of following the terms and
conditions either of that specified version or of any later version that has
been published (not as a draft) by the Free Software Foundation. If the
Document does not specify a version number of this License, you may choose any
version ever published (not as a draft) by the Free Software Foundation.

How to use this License for your documents

To use this License in a document you have written, include a copy of the
License in the document and put the following copyright and license notices
just after the title page:

    Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free Documentation
License, Version 1.1 or any later version published by the Free Software
Foundation; with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. A copy
of the license is included in the section entitled "GNU Free Documentation
License". 

If you have no Invariant Sections, write "with no Invariant Sections" instead
of saying which ones are invariant. If you have no Front-Cover Texts, write "no
Front-Cover Texts" instead of "Front-Cover Texts being LIST"; likewise for
Back-Cover Texts.

If your document contains nontrivial examples of program code, we recommend 
releasing these examples in parallel under your choice of free software license, 
such as the GNU General Public License, to permit their use in free software.
]]></programlisting>
</appendix>

</book>
