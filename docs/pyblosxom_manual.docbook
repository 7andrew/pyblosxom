<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
<bookinfo>
<title>PyBlosxom Manual</title>
<subtitle>for PyBlosxom 1.1</subtitle>

<!--
  If you do any editing on this document, add your name to the below
  author list.
-->
<authorgroup>
<author>
<firstname>Will</firstname>
<surname>Guaraldi</surname>
</author>
</authorgroup>

</bookinfo>

<toc></toc>

<chapter id="installation">
<title>Installing PyBlosxom</title>
<para>
There are many ways to install PyBlosxom. This particular installation 
guide covers the typical installation for a single user on Apache with 
PyBlosxom running as a CGI script.
</para>
<para>
There are other ways to install Pyblosxom depending on how you want it 
to behave as well as what webserver you're installing Pyblosxom on top of.
</para>
<para>
This installation assumes you have some understanding of CGI, Apache 
configuration, and know how to manipulate files and directories. If this 
doesn't sound like you, maybe you should get a friend to help out or ask 
for help on the pyblosxom-users mailing list.
</para>
<para>
If you are upgrading your version of PyBlosxom, follow the instructions 
here and also read the README for differences between this version and 
the previous versions.
</para>

<sect1>
<title>Pre-requisites</title>
<para>
You will need:
</para>
<itemizedlist>
<listitem>
<para>
a web-server - preferably Apache (if only because that's what most of the 
developers use), but PyBlosxom can probably be made to run on any web s
erver with CGI abilities.
</para>
</listitem>
<listitem>
<para>
Python version 2.1 or later
</para>
</listitem>
<listitem>
<para>
a text editor (notepad, vi, emacs, nano, ...) 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1>
<title>Setting up PyBlosxom as a Single-User Local Installation with CGI</title>
<para>
These are the steps for setting up PyBlosxom as a single-user local 
installation:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
untar the PyBlosxom tar ball
</para>
</listitem>
<listitem>
<para>
copy web/pyblosxom.cgi and web/config.py to your cgi-bin directory
</para>
</listitem>
<listitem>
<para>
create a directory to hold your flavour templates and entries--this is 
your datadir
</para>
</listitem>
<listitem>
<para>
using any text editor, edit your config.py file--there are comments as to what all the properties affect
</para>
<itemizedlist>
  <listitem>
  <para>
  make sure to set the datadir property to the full path of the directory you just created to store your data in [1]
  </para>
  </listitem>
  <listitem>
  <para>
  make sure to set the codebase property to the directory you untarred PyBlosxom into [2] 
  </para>
  </listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
run ./pyblosxom.cgi--this will verify your configuration and installation and help you with any issues
</para>
</listitem>
<listitem>
<para>
using any text editor, open up a file called firstpost.txt in your datadir and write: 
</para>
<programlisting role="html">
<![CDATA[
First Post
<p>
   This is the first post in my blog.
</p>
]]>
</programlisting>
</listitem>
<listitem>
<para>
test it in a web-browser 
</para>
</listitem>
</orderedlist>

<para>
[1] - You should always use / as the directory separater character 
regardless of what OS you're on. For example, this should work in Linux, 
Unix, or Windows:
</para>

<programlisting role="python">
py["datadir"] = "/pyblosxom/datadir/blog/"
</programlisting>

<para>
FIXME - If you're using Windows and the pyblosxom.cgi file is on a 
different drive than your blog datadir, what should they do?
</para>

<para>
[2] - For the codebase, you should use an explicit path and use appropriate 
directory separators. For example, this works on Windows:
</para>

<programlisting role="python">
py["codebase"] = "c:\\pyblosxom\\"
</programlisting>

<para>
And this would work fine on Linux and Unix:
</para>

<programlisting role="python">
py["codebase"] = "/home/willg/pyblosxom/"
</programlisting>
</sect1>
<sect1>
<title>Setting up PyBlosxom as a Site-Wide Multi-User Installation</title>
<para>
For a site-wide simple installation:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
untar the pyblosxom tar file into a temporary directory
</para>
</listitem>
<listitem>
<para>
switch over to a superuser such as root
</para>
</listitem>
<listitem>
<para>
run the command "python setup.py install" to install the Pyblosxom libraries in your python installation 
</para>
</listitem>
</orderedlist>

<para>
That installs the PyBlosxom libraries site-wide. Each user needs to copy the config.py and pyblosxom.cgi files into their cgi-bin directory, set up a datadir, set up a plugins dir (though you could have a central one for all users on the server), and edit their config.py file. Follow the steps a bove in the single-user installation for these steps.
</para>
</sect1>

<sect1>
<title>Setting up PyBlosxom as an ISP-like Installation</title>
<para>
This can be done (and has been done). FIXME Need instructions for it. 
</para>
</sect1>
</chapter>








<chapter id="configuration">
<title>Configuring PyBlosxom</title>
<para>
PyBlosxom and PyBlosxom plugins expose many behavioral switches and configuration properties through the config.py file.
</para>
<sect1>
<title>Configuration Variables</title>
<para>
PyBlosxom requires you to create a configuration file to set the various variables that will guide PyBlosxom's behavior. This configuration file is a text file of Python code. If you can't read Python code, don't worry too much--you should be able to change the values of the file without actually knowing the ins and outs of Python syntax.
</para>
<para>
Here's a list of configuration variables:
</para>

<table>
<title>Configuration Variables</title>
<tgroup cols="4">
<thead>
<row>
<entry>variable</entry>
<entry>required</entry>
<entry>data type</entry>
<entry>description</entry>
</row>
</thead>
<tbody>
<row>
<entry>blog_title</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  the title of your blog
  </para>
  <programlisting role="python">
py["blog_title"] = "Will's Blog of Awesome Stuff"
  </programlisting>
</entry>
</row>
<row>
<entry>blog_description</entry>
<entry>no</entry>
<entry>string</entry>
<entry>
  <para>
  the description of your blog
  </para>
  <programlisting role="python">
py["blog_description"] = "Blog of thoughts, comments, code examples, and such."
  </programlisting>
</entry>
</row>
<row>
<entry>blog_author</entry>
<entry>no</entry>
<entry>string</entry>
<entry>
  <para>
  this is you--your name.
  </para>
  <programlisting role="python">
<![CDATA[
py["blog_author"] = "Will <will at blah dot org>"
]]>
  </programlisting>
</entry>
</row>
<row>
<entry>blog_language</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the primary language code of your blog.
  </para>
  <programlisting role="python">
py["blog_language"] = "en"
  </programlisting>
</entry>
</row>
<row>
<entry>blog_encoding</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the encoding of your blog. iso-8859-1, utf-8, ...
  </para>
  <programlisting role="python">
py["blog_encoding"] = "iso-8859-1"
  </programlisting>
</entry>
</row>
<row>
<entry>datadir</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the full path to where your PyBlosxom entries are kept.
  </para>
  <programlisting role="python">
py["datadir"] = "/home/will/blog/datadir/"
  </programlisting>
</entry>
</row>
<row>
<entry>logdir</entry>
<entry>yes</entry>
<entry>string</entry>
<entry>
  <para>
  this is the full path to the directory for logs.
  </para>
  <programlisting role="python">
py["logdir"] = "/home/will/blog/logs/"
  </programlisting>
</entry>
</row>
<row>
<entry>num_entries</entry>
<entry>no</entry>
<entry>int</entry>
<entry>
  <para>
  how many entries should show up on a given page? This defaults to 0 which will show all entries.
  </para>
  <programlisting role="python">
py["num_entries"] = 20
  </programlisting>
</entry>
</row>
<row>
<entry>plugin_dirs</entry>
<entry>no</entry>
<entry>list of strings</entry>
<entry>
  <para>
  the list of directories your plugins are stored in.
  </para>
  <programlisting role="python">
py["plugin_dirs"] = ["/home/will/pyblosxom/plugins/"]
  </programlisting>
</entry>
</row>
<row>
<entry>load_plugins</entry>
<entry>no</entry>
<entry>list of strings</entry>
<entry>
  <para>
  if this is not set, then PyBlosxom will load all the plugins in the plugin dirs you specified in alphabetical order. If this is set, then PyBlosxom will only load the plugins specified.
  </para>
  <programlisting role="python">
py["load_plugins"] = ["pycalendar", "rss2renderer"]
  </programlisting>
</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Additionally, any variables you set in your config.py file are available in your flavour templates.
</para>
</sect1>

<sect1>
<title>Interesting things you can do with config.py files</title>
<para>
The config.py file is a Python code file. This allows you to use Python in the file itself to set properties. For example, say you wanted num_entries not to be set unless the user requests a page with flav=rss in the query string. You could do the following in your config.py file:
</para>

<programlisting role="python">
import os
query_string = os.environ.get("QUERY_STRING", "")
if "flav=rss" in query_string:
   py['num_entries'] = 20
</programlisting>
<para>
This will check to see if "flav=rss" is in the query string and if so, it'll set the num_entries property to 20.
</para>
<para>
FIXME - talk about how someone could do a site-wide config file 
</para>
</sect1>
</chapter>






<chapter>
<title>Flavours</title>
<para>
PyBlosxom uses renderers to take the data provided in the entries and 
transform it into the output.  Output can be html, xhtml, xml, or anything 
else.  The default renderer can be set in your config file like this:
</para>
<programlisting role="python">
py["renderer"] = "blosxom"
</programlisting>
<para>
Renderers can be plugins.  The rss2renderer is implemented this way.
</para>
<para>
PyBlosxom comes with two renderers: debug and blosxom.  It is possible 
and not too difficult to build other renderers for PyBlosxom. 
These other renderers can use other template engines like Cheetah or 
htmltmpl.  
</para>
<para>
The debug renderer displays all the data in the various parts of the 
PyBlosxom Request object.  This is a really great way of seeing what 
variables you have at your disposal for your flavour templates.  It also 
helps you to track down problems you might be having.
</para>
<para>
This chapter talks specifically about using the Blosxom renderer.
</para>

<sect1>
<title>flavours and templates</title>
<para>
The blosxom renderer uses the same template style that Blosxom uses.  As
such, you can use most Blosxom flavour templates without too many 
modifications.
</para>
<para>
When you install PyBlosxom, it comes with a default html flavour. It's 
built into the renderer itself and doesn't require you to create or copy 
over any template files. It's incredibly bland. Most people will either 
create a flavour or download one from our flavour registry.
</para>
<para>
The Blosxom renderer uses the following templates:
</para>
<itemizedlist>
<listitem><para>content_type - holds the content type of the flavour</para></listitem>
<listitem><para>head - holds everything before all the entries</para></listitem><listitem><para>story - holds a single entry</para></listitem>
<listitem><para>foot - holds everything after all the entries</para></listitem>
<listitem><para>date_head - shows at the start of a date (this only exists in PyBlosxom)</para></listitem>
<listitem><para>date_foot - shows at the end of a date (this only exists in PyBlosxom)</para></listitem>
</itemizedlist>
<para>
FIXME - this is a terrible description
</para>
<para>
The Blosxom renderer allows you to have different "styles" to your site. 
We call a style a "flavour". A flavour consists of one of each kind of 
template above (though I tend to skip the date_head and date_foot templates 
and use the default ones) where all of them have the same look and feel. 
To create the flavour, all of these template files will have the same 
extension.
</para>
<para>
For example, if you want to create a "joy" flavour, you would create the 
following files:
</para>

<itemizedlist>
<listitem><para>content_type.joy</para></listitem>
<listitem><para>head.joy</para></listitem>
<listitem><para>story.joy</para></listitem>
<listitem><para>foot.joy</para></listitem>
<listitem><para>date_head.joy (optional)</para></listitem>
<listitem><para>date_foot.joy (optional)</para></listitem>
</itemizedlist>

<para>
You can have as many flavours as you like. Most PyBlosxom sites have an 
html flavour and that's it. Then RSS rendering is done either with an rss 
flavour (for RSS 0.9.1) or an rss plugin which has its own renderer (for 
RSS 2.0, ATOM, and other more complicated feed formats).
</para>
</sect1>

<sect1>
<title>Template Variables</title>
<para>
Here's the variables that are available in your templates. Plugins will 
add variables. To get a complete list of what variables are available in 
'your' blog, use the debug renderer by changing the renderer property in 
your config.py file to debug like this:
</para>
<programlisting role="python">
py["renderer"] = "debug"
</programlisting>
<para>
That will tell you all kinds of stuff about the data structures involved 
in the request.
</para>

<sect2>
<title>Variables from config.py</title>
<para>
These template variables are available to all templates. They come directly 
from your config.py file.
</para>

<table>
<title>template variables from config.py</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>blog_description</entry>
<entry>the description of the blog</entry>
<entry>blosxom with a touch of python</entry>
</row>
<row>
<entry>blog_title</entry>
<entry>the title of the blog</entry>
<entry>RoughingIT - pyblosxom : /weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>blog_language</entry>
<entry>the language of the blog</entry>
<entry>en</entry>
</row>
<row>
<entry>blog_encoding</entry>
<entry>the encoding of the blog</entry>
<entry>iso8859-1</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Additionally, any other properties you set in config.py are available in your templates. If you wanted to create an blog_email variable, you could add:
</para>
<programlisting role="python">
py["blog_email"] = "joe@example.com"
</programlisting>
<para>
to your config.py file and it would be available in all your templates.
</para>
<para>
Note: because the config.py file is written Python code and properties are available in all your templates, this allows you do some sophisticated things.
</para>
<para>
FIXME - examples?
</para>
</sect2>

<sect2>
<title>Calculated Template Variables</title>
<para>
These template variables are available to all templates as well. They are calculated based on the request.
</para>

<table>
<title>Calculated template variables</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>content_type</entry>
<entry>the content type of this page</entry>
<entry>text/html</entry>
</row>
<row>
<entry>root_datadir</entry>
<entry>the root datadir of this page?</entry>
<entry>/home/subtle/blosxom/weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>url</entry>
<entry>the PATH_INFO to this page</entry>
<entry>pyblosxom/weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>flavour</entry>
<entry>the flavour for this page</entry>
<entry>html</entry>
</row>
<row>
<entry>pi_yr</entry>
<entry>the four-digit year the user requested</entry>
<entry>2002</entry>
</row>
<row>
<entry>pi_mo</entry>
<entry>the month name the user requested</entry>
<entry>Sep</entry>
</row>
<row>
<entry>pi_da</entry>
<entry>the day number the user requested</entry>
<entry>15</entry>
</row>
<row>
<entry>pi_bl</entry>
<entry>the entry the user requested to see</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
</tbody>
</tgroup>
</table>

</sect2>

<sect2>
<title>Template Variables Only Available in the story Template</title>
<para>
These template variables are only available in your story template.
</para>
<table>
<title>variables in the story template</title>
<tgroup cols="3">
<thead>
<row>
<entry>variable name</entry>
<entry>description</entry>
<entry>example</entry>
</row>
</thead>
<tbody>
<row>
<entry>title</entry>
<entry>title of the entry</entry>
<entry>First Post!</entry>
</row>
<row>
<entry>filename</entry>
<entry>templete file name and path of the entry</entry>
<entry>/home/subtle/blosxom/weblogs/tools/pyblosxom/index.txt</entry>
</row>
<row>
<entry>file_path</entry>
<entry>just the filename and extensions of the entry</entry>
<entry>index.txt</entry>
</row>
<row>
<entry>fn</entry>
<entry>just the filename (no extension)</entry>
<entry>index</entry>
</row>
<row>
<entry>absolute_path</entry>
<entry>the category/path of the entry</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>body</entry>
<entry>the text of the entry</entry>
<entry>first post!</entry>
</row>
<row>
<entry>tb_id</entry>
<entry>the trackback id of the entry</entry>
<entry>_index</entry>
</row>
<row>
<entry>path</entry>
<entry>the category/path of the entry</entry>
<entry>weblogs/tools/pyblosxom</entry>
</row>
<row>
<entry>yr</entry>
<entry>the four digit year of the mtime of this entry</entry>
<entry>2004</entry>
</row>
<row>
<entry>mo</entry>
<entry>the month abbreviation of the mtime of this entry</entry>
<entry>Jan</entry>
</row>
<row>
<entry>mo_num</entry>
<entry>the month number of the mtime of this entry</entry>
<entry>01</entry>
</row>
<row>
<entry>ti</entry>
<entry>the hour and minute of the mtime of this entry</entry>
<entry>16:40</entry>
</row>
<row>
<entry>date</entry>
<entry>the date string of the mtime of this entry</entry>
<entry>Sun, 23 May 2004</entry>
</row>
<row>
<entry>fulltime</entry>
<entry>another date string</entry>
<entry>20040523164000</entry>
</row>
<row>
<entry>timetuple</entry>
<entry>the time tuple</entry>
<entry>(2004, 5, 23, 16, 40, 0, 6, 144, 1)</entry>
</row>
<row>
<entry>mtime</entry>
<entry>seconds since the epoch</entry>
<entry>1085348400.0</entry>
</row>
<row>
<entry>dw</entry>
<entry>the day of the week</entry>
<entry>Sunday</entry>
</row>
<row>
<entry>da</entry>
<entry>the day of the month</entry>
<entry>23</entry>
</row>
<row>
<entry>w3cdate</entry>
<entry>the w3c date</entry>
<entry>2004-05-23T21:40:00Z</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2>
<title>Template Variables from Plugins</title>
<para>
Additionally, many plugins will create additional variables. Refer to the plugin's documentation for what variables it creates, where the variables are available, and what the variables do.
</para>
</sect2>
</sect1>

<sect1>
<title>Invoking a Flavour</title>
<para>
The flavour for a given page is specified in the extension of the file being requested. For example:
</para>

<table>
<title>Examples of url requests</title>
<tgroup cols="2">
<thead>
<row>
<entry>url</entry>
<entry>what happens</entry>
</row>
</thead>
<tbody>
<row>
<entry>http://some.blog.org/</entry>
<entry>brings up the index in the default flavour which is "html"</entry>
</row>
<row>
<entry>http://some.blog.org/index.html</entry>
<entry>brings up the index in the "html" flavour</entry>
</row>
<row>
<entry>http://some.blog.org/index.rss</entry>
<entry>brings up the index in the "rss" flavour (which by default is RSS 0.9.1)</entry>
</row>
<row>
<entry>http://some.blog.org/2004/05/index.joy</entry>
<entry>brings up the index for May of 2004 in the "joy" flavour</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
Additionally, you can specify the flavour using the flav QueryString variable. Examples:
</para>
<table>
<title>Specifying flavour using the querystring</title>
<tgroup cols="2">
<thead>
<row>
<entry>url</entry>
<entry>what happens</entry>
</row>
</thead>
<tbody>
<row>
<entry>http://some.blog.org/</entry>
<entry>brings up the index in the default flavour which is "html"</entry>
</row>
<row>
<entry>http://some.blog.org/?flav=rss</entry>
<entry>-brings up the index in the "rss" flavour</entry>
</row>
<row>
<entry>http://some.blog.org/2004/05/index?flav=joy</entry>
<entry>brings up the index for May of 2004 in the "joy" flavour</entry>
</row>
</tbody>
</tgroup>
</table>
<para>
You can change the default flavour from "html" to some other flavour in your config.py file with the default_flavour property:
</para>
<programlisting role="python">
py["default_flavour"] = "joy"
</programlisting>
</sect1>

<sect1>
<title>Overriding Flavour Templates by Category</title>
<para>
If you want to override the flavour for a particular category, just place the override template files within the directory corresponding with the category.
</para>
<para>
For example, your directory tree may look something like this:
</para>
<programlisting role="filelisting">
my_blog/
   |- content/
      |- content_type.html         <- 1
      |- head.html                 <- 1
      |- story.html                <- 1
      |- foot.html                 <- 1
      |- DailyAffairs/
      |- Travel/
      |- Coding/
         |- content_type.html      <- 2
         |- head.html              <- 2
         |- story.html             <- 2
         |- foot.html              <- 2
         |- Python/
         |- C/
</programlisting>
<para>
The default flavour for all your directories would be "html" and would be taken from the flavour marked "1". However, if they user is looking at the Coding category or any categories under Coding, they'll see the "html" flavour templates marked by "2".
</para>
</sect1>

<sect1>
<title>Basic set of templates</title>
<para>
Here's a really basic set of templates for an html flavour.
</para>

<table>
<title>Basic set of templates for an html flavour</title>
<tgroup cols="2">
<thead>
<row>
<entry>template name</entry>
<entry>content</entry>
</row>
</thead>
<tbody>
<row>
<entry>content_type.html</entry>
<entry>text/html</entry>
</row>
<row>
<entry>head.html</entry>
<entry>
<programlisting role="html">
<![CDATA[
<html>
<head>
  <title>$blog_title $pi_da $pi_mo $pi_yr</title>
</head>
<body>
<h1>$blog_title</h1>
<p>$pi_da $pi_mo $pi_yr</p>
]]>
</programlisting>
</entry>
</row>
<row>
<entry>story.html</entry>
<entry>
<programlisting role="html">
<![CDATA[
<h3><a name="$fn">$title</a></h3>
<div class="blosxomStory">
$body
<p>
  posted at: $ti | 
  path: <a href="$base_url/$absolute_path" title="path">/$absolute_path</a> | 
  <a href="$base_url/$file_path.$flavour">permalink</a>
</p>
</div>
]]>
</programlisting>
</entry>
</row>
<row>
<entry>foot.html</entry>
<entry>
<programlisting role="html">
<![CDATA[
<p>
  Made with PyBlosxom
</p>
</body>
</html>
]]>
</programlisting>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>
</chapter>





<chapter id="plugins">
<title>Plugins</title>
<para>
PyBlosxom allows you to extend its base functionality using drop-in plugins. These plugins can extend functionality by providing addition template variables for things like archive lists, calendars, and such. PyBlosxom uses CallbackChains to call functions in the plugins so that they can do their thing.
</para>

<sect1>
<title>Setting PyBloxsom up to Use Plugins</title>
<para>
There are two properties in your config.py file that affect the behavior for loading plugins.
</para>
<para>
The first one is the plugin_dirs property which is a list of strings specifying all the directories you might have plugins. For example:
</para>
<programlisting role="python">
py["plugin_dirs"] = ["/home/will/pybloxsom/plugins"]
</programlisting>

<para>
This will cause PyBlosxom to look in this specific directory for plugins.
</para>

<para>
The other property is the load_plugins property. If you don't have this set at all, PyBlosxom will load all plugins it finds in the plugin directories you've specified and load them. It will look in each directory in order as you've specified. It will load the plugins in each directory in alphabetical order by filename.
</para>

<para>
The other way to load plugins is by specifying the plugins explicitly by setting the load_plugins property. PyBlosxom will load only the plugins you've specified and will load them in the order you've specified. The load_plugins property takes a list of strings. For example:
</para>

<programlisting role="python">
py["load_plugins"] = ["calendar", "category", "booklist"]
</programlisting>

<para>
This will load the plugins whose filenames are "calendar.py", "category.py", and "booklist.py". It will load them in that order and will only load those plugins even if you have other plugins in your plugin directories.
</para>
</sect1>

<sect1>
<title>Finding Plugins</title>
<para>
You can find plugins in the plugin registry at http://pyblosxom.sourceforge.net/ .
</para>
<para>
Additionally, some people write plugins, but never register with the plugin registry. Sometimes this is because the author doesn't feel the plugin is finished for public consumption. Even so, it might meet your needs. The best way to find these plugins is to ask on the pyblosxom-users mailing list for a plugin that has the functionality you desire.
</para>
</sect1>

<sect1>
<title>Installing Plugins</title>
<para>
When you're installing a plugin, refer to its documentation. The documentation could be in a README file, but more likely it's in the plugin code itself at the top of the file. This documentation should tell you how to install the plugin, what template variables the plugin exposes, how to invoke the plugin, how to get in touch with the author should you find bugs or need help, and any additional things you should know about.
</para>
<para>
Most plugins should have a pretty easy installation method. You should be able to copy the plugin into the directory defined in your config.py file in the plugin_dirs property. Then there might be some additional properties you'll ahve to set in your config.py file to define the plugin's behavior. That should be about it. On some occasions, you may have to change the code in the plugin itself to meet your specific needs.
</para>
</sect1>

<sect1>
<title>Writing Your Own Plugins</title>
<para>
You may find that you desire functionality and there is no plugin that anyone knows about that performs that functionality. It's probably best at this point for you to either pay someone to write the plugin you need or write it yourself.
</para>
<para>
Plugins are pretty easy to write and can cover a lot of really different functionality. The best way to learn how to write PyBlosxom plugins is to read through the plugins in the plugin registry. Many of them are well written and may provide insight as to how to solve your specific problem.
</para>
<para>
Additionally, feel free to ask for help on the pyblosxom-users and pyblosxom-devel mailing lists. 
</para>
</sect1>
</chapter>






<chapter id="staticrendering">
<title>Static Rendering</title>
<para>
Static rendering made its first appearance in PyBlosxom 1.0. It fills the functionality gap for people who want to use PyBlosxom, but don't have a web-server with CGI installed, don't have CGI access, or can't run PyBlosxom for one of a myriad of other reasons. Static rendering allows these people to run PyBlosxom on their local machine, write blog entries, render their entire site into HTML, and then use ftp or some other file copy method to move the pages up to their static web-site.
</para>
<para>
PyBlosxom's static rendering allows for incremental building. It can scan your entries, figure out what's changed, and render only the pages that need re-rendering.
</para>
<para>
Beyond that, it's not particularly sophisticated.
</para>

<sect1>
<title>Configuring static rendering</title>
<para>
These are the instructions for configuring static rendering in PyBlosxom.
</para>

<orderedlist>
<listitem>
<para>
Install PyBlosxom. When you're copying the pyblosxom.cgi and config.py files, you don't have to put them in a CGI directory--you can put them in any directory you have permissions in. For example, I created a directory /home/willg/pyblosxom/ and put both files in there.
</para>
</listitem>
<listitem>
<para>
Add static_dir to your config.py file. This is the directory we will save all the static output. The value of static_dir should be a string representing the absolute path of the output directory for static rendering.
</para>
</listitem>
<listitem>
<para>
Add static_flavours to your config.py file. The value of static_flavours should be a list of strings representing all the flavours that should be rendered. This defaults to [ "html" ].
</para>
</listitem>
<listitem>
<para>
Add static_monthnames to your config.py file. The value (either 1 or 0) will determine if you want month names (such as April) in the static pages. On some versions of Pyblosxom, month names are not supported, and you will need to use month numbers.
</para>
</listitem>
<listitem>
<para>
Add static_monthnumbers to your config.py file. The value (either 1 or 0) will determine if you want month numbers (such as 04 for April) in the static pages.
</para>
</listitem>
<listitem>
<para>
Set base_url in your config.py file to the base url your blog will have. For example, if your static_dir were set to /home/willg/public_html and the url for that directory were http://www.bluesock.org/~willg/, then you probably want your base_url to be http://www.bluesock.org/~willg/. 
</para>
</listitem>
</orderedlist>
</sect1>

<sect1>
<title>Running static rendering</title>

<sect2>
<title>Render everything</title>
<para>
Now you can run static rendering:
</para>
<programlisting role="shell">
% cd directory-with-pyblosxom.cgi-in-it 
% ./pyblosxom.cgi --static 
</programlisting>
<para>
Lots of output will appear as it figures out all the urls that need to be rendered and then renders them all one by one.
</para>
</sect2>

<sect2>
<title>Incremental rendering</title>
<para>
We have incremental rendering which will go find all the entries that have changed since we rendered them and then re-render them. It does this by comparing the mtime on the entry file with the mtime on the rendererd file.
</para>
<para>
It works like this:
</para>
<programlisting role="shell">
% cd directory-with-pyblosxom.cgi-in-it 
% ./pyblosxom.cgi --static --incremental 
</programlisting>
</sect2>
</sect1>

<sect1>
<title>Rendering other urls</title>
<para>
Some plugins provide other urls that are part of your site, but not really part of your blog since they're not related to entries. Examples of this include the plugininfo plugin which provides information about the plugins that you're running. You can set the static_urls property in config.py to a list of all the urls that need to be rendered every time. This list could include:
</para>

<itemizedlist>
<listitem><para>RSS, FOAF, OPML, ATOM or any other kind of feeds</para></listitem>
<listitem><para>urls for plugins that aren't related to entries (plugininfo, pystaticfile, booklist, ...)</para></listitem>
</itemizedlist>

<para>
static_urls takes a list of strings where each string is a url to be rendered. For example if I wanted to render the booklist page and the RSS feed for my main page, I would set it like this:
</para>

<programlisting role="python">
py["static_urls"] = ["/booklist/index.html", "/index.xml"]
</programlisting>
</sect1>

<sect1>
<title>Additional thoughts</title>
<para>
Static rendering is pretty simplistic. We use the tools.render_url function to render each url. Plugins that need to re-render the entry pages because something has changed (e.g. comments, pingbacks, ...), should call this function.
</para>
<para>
If you want to statically render your blog every night, you could write a shell script like this:
</para>
<programlisting role="shell">
#!/bin/bash 
 
cd directory-with-pyblosxom.cgi
./pyblosxom.cgi --static 
find static_dir-directory -mmin +30 -exec 'rm' '{}' ';' 
</programlisting>
<para>
That'll re-render everything, then delete any files in your static dir that are older than 30 minutes (in case you moved entries from one category to another or deleted an entry or whatever). 
</para>
</sect1>
</chapter>







<chapter>
<title>Syndication</title>

<sect1>
<title>RSS</title>
<para>
PyBlosxom comes with an rss flavour that produces RSS 0.9.1 output.
</para>
<para>
FIXME - Talk about setting up the RSS 0.9.1 flavour
</para>
<para>
There is an rss2renderer plugin in the plugin registry that produces RSS 2.0 output.
</para>
</sect1>

<sect1>
<title>Atom</title>
<para>
FIXME - talk about setting up the rss2renderer
</para>
</sect1>

<sect1>
<title>Other formats</title>
<para>
FIXME - Other formats? 
</para>
</sect1>
</chapter>








<chapter>
<title>PyBlosxom Architecture</title>
<para>
The architecture for PyBlosxom has evolved over time. The mission is to build an easily augmented blog server that uses the file system for data storage. Using the file system allows PyBlosxom to fit in with other applications rather than forcing PyBlosxom to solve all problems all by itself.
</para>

<sect1>
<title>Parts</title>
<para>
PyBlosxom is composed of a few different parts:
</para>
<itemizedlist>
<listitem>
<para>
pyblosxom.cgi - This is the CGI script that is executed by your web-server, pulls in configuration variables from config.py and then instantiates PyBlosxom objects to handle the request.
</para>
</listitem>
<listitem>
<para>
the Pyblosxom package - This is the Python package that holds the PyBlosxom objects and utility functions that handle the request.
</para>
<itemizedlist>
   <listitem>
   <para>
   the entries package - Handles the abstraction allowing PyBlosxom to use 
   entries other than those solely found on the file system.
   </para>
   </listitem>
   <listitem>
   <para>
   the renderers package - PyBlosxom can handle different renderers. The 
   renderer gets a list of entries to be rendered and can render them using 
   whatever means it so desires: blosxom templates, htmltmpl templates, 
   Cheetah templates, hard-coded RSS 2.0 markup, ...
   </para>
   </listitem>
   <listitem>
   <para>
   the cache package - PyBlosxom allows for entry-level caching. This helps 
   in cases where your entries are stored in a format that requires a lot 
   of processing to convert to HTML. 
   </para>
   </listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
PyBlosxom's look'n'feel and behavior is then augmented by:
</para>

<itemizedlist>
<listitem>
<para>
plugins - Plugins allow you to augment PyBlosxom's default behavior. These 
you can get from the plugin registry or write yourself.
</para>
</listitem>
<listitem>
<para>
flavour templates - Flavour templates allow you to create the look and feel 
of your blog. These you can get from the flavour registry or write yourself. 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1>
<title>Lifecycle of a PyBlosxom request</title>
<para>
This is the life cycle of a single PyBlosxom request. It involves the following "entities":
</para>
<itemizedlist>
<listitem>
<para>
pyblosxom.cgi - A script found in the web/ directory. This is the CGI 
script that handles PyBlosxom requests.
</para>
</listitem>
<listitem>
<para>
config.py - The configuration file that defines the behavior and properties 
of your blog.
</para>
</listitem>
<listitem>
<para>
PyBlosxom.pyblosxom - The pyblosxom module holds the default PyBlosxom 
behavior functions. It also defines the Request class and the PyBlosxom class.
</para>
</listitem>
<listitem>
<para>
Pyblosxom.pyblosxom.Request - The Request object holds the state of the 
PyBlosxom request at any given time throughout the lifecycle fo the request. 
The Request is passed to most callbacks in the args dict as "request".
</para>
</listitem>
<listitem>
<para>
Pyblosxom.pyblosxom.PyBlosxom - The PyBlosxom object holds a list of 
registered plugins, what callbacks they're registered to, and the methods 
that handle the the actual request. 
</para>
</listitem>
</itemizedlist>

<para>
The PyBlosxom request lifecycle starts with the web-server executing 
pyblosxom.cgi.
</para>
<programlisting role="lifecycle">

1. pyblosxom.cgi: loads config.py
2. pyblosxom.cgi: instantiates a Request object
3. pyblosxom.cgi: instantiates a PyBlosxom object passing it the Request object
4. pyblosxom.cgi: calls run() on the PyBlosxom instance
      1. PyBlosxom instance, run method: calls initialize
            1. PyBlosxom instance, initialize method: imports the plugins
            2. PyBlosxom instance, initialize method: calls the entryparser callback to get a map of all the entry types we can handle 
      2. PyBlosxom instance, run method: calls the start callback to allow plugins to do any intialization they need to do
      3. PyBlosxom instance, run method: calls the handle callback allowing plugins to fully handle the request.
         If a plugin handles the request, the plugin should return a 1 signifying it has done so. At that point, PyBlosxom will stop trying to find a plugin to handle the request.
         If no plugin handles the request, then PyBlosxom will handle the request using the blosxom_handler PyBlosxom will handle the request using the blosxom_handler.
      4. PyBlosxom instance, run method: calls the end callback to allow plugins to do any cleanup they need to do 
</programlisting>
</sect1>

<sect1>
<title>Lifecycle of the blosxom_handler</title>
<para>
This describes what the blosxom_handler does. This is the default handler for PyBlosxom. It's called by the PyBlosxom instance in the run method if none of the plugins have handled the request already.
</para>
<programlisting role="lifecycle">
1. calls the renderer callback to get a renderer instance
   If none of the plugins return a renderer instance, then we go check to see if config.py has the renderer property set and use that.
   If there is no renderer property set, we use the blosxom renderer which is found in the pyblosxom.PyBlosxom.renderer package.
2. calls the pathinfo callback which allows all the plugins to help figure out what to do with the HTTP URL/QUERYSTRING we've been given
3. calls the filelist callback which returns a list of entries to render based on what the path info is
4. calls the prepare callback which allows plugins to transform the entries and any other data in the Request object prior to rendering
5. renders the entries 
</programlisting>
</sect1>

<sect1>
<title>Lifecycle of the blosxom renderer</title>
<para>
The blosxom renderer renders the entries in a similar fashion to what Blosxom does. The blosxom renderer uses flavour templates and template variables. It also has a series of callbacks allowing plugins to modify templates and entry data at the time of rendering that specific piece.
</para>
<programlisting role="lifecycle">
1. renders the content_type template
2. calls the head callback and renders the head template
3. calls the date_head callback and renders the date_head template
4. for each story:
      1. if the mtime on this entry is different than the last entry, it calls the date_foot callback, renders the date_foot template, calls the date_head callback and renders the date_head template
      2. calls the story callback and renders the story template 
5. calls the date_foot callback and renders the date_foot template
6. renders the foot template (calls the foot callback 
</programlisting>
</sect1>

<sect1>
<title>Callbacks</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Entry parsers</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Pre-formatters and post-formatters</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Renderers</title>
<para>
FIXME 
</para>
</sect1>
</chapter>
</book>
