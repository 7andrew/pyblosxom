<!--
  CHAPTER ARCHITECTURE
-->

<chapter>
<title>PyBlosxom Architecture</title>
<para>
The architecture for PyBlosxom has evolved over time. The mission is to 
build an easily augmented blog server that uses the file system for data 
storage. Using the file system allows PyBlosxom to fit in with other 
applications rather than forcing PyBlosxom to solve all problems all by 
itself.
</para>
,para>
In general, this chapter is lacking pretty severely.  The code itself
is fairly well documented and you should always consider the code to be
an authority when the code and this manual are in disagreement.
</para>
<para>
FIXME - rework this whole chapter.
</para>

<sect1>
<title>Parts</title>
<para>
PyBlosxom is composed of several parts:
</para>
<itemizedlist>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> - This is the CGI script that is executed 
by your web-server, pulls in configuration variables from 
<filename>config.py</filename> and then instantiates PyBlosxom objects to 
handle the request.
</para>
</listitem>
<listitem>
<para>
the <filename>Pyblosxom</filename> package - This is the Python package that 
holds the PyBlosxom objects and utility functions that handle the request.
</para>
<itemizedlist>
   <listitem>
   <para>
   the <filename>entries</filename> package - Handles the abstraction allowing 
   PyBlosxom to use entries other than those solely found on the file system.
   </para>
   </listitem>
   <listitem>
   <para>
   the <filename>renderers</filename> package - PyBlosxom can handle different 
   renderers. The renderer gets a list of entries to be rendered and can render 
   them using whatever means it so desires: blosxom templates, htmltmpl templates, 
   Cheetah templates, hard-coded RSS 2.0 markup, ...
   </para>
   </listitem>
   <listitem>
   <para>
   the <filename>cache</filename> package - PyBlosxom allows for entry-level 
   caching. This helps in cases where your entries are stored in a format that 
   requires a lot of processing to convert to HTML. 
   </para>
   </listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
PyBlosxom's look'n'feel and behavior is then augmented by:
</para>

<itemizedlist>
<listitem>
<para>
plugins - Plugins allow you to augment PyBlosxom's default behavior. These 
you can get from the plugin registry or write yourself.
</para>
</listitem>
<listitem>
<para>
flavour templates - Flavour templates allow you to create the look and feel 
of your blog. These you can get from the flavour registry or write yourself. 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1>
<title>Lifecycle of a PyBlosxom Request</title>
<para>
This is the life cycle of a single PyBlosxom request. It involves the 
following "entities":
</para>
<itemizedlist>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> - A script found in the web/ directory. 
This is the CGI script that handles PyBlosxom requests.
</para>
</listitem>
<listitem>
<para>
<filename>config.py</filename> - The configuration file that defines the 
behavior and properties of your blog.
</para>
</listitem>
<listitem>
<para>
<filename>PyBlosxom.pyblosxom</filename> - The pyblosxom module holds the 
default PyBlosxom behavior functions. It also defines the Request class and 
the PyBlosxom class.
</para>
</listitem>
<listitem>
<para>
<filename>Pyblosxom.pyblosxom.Request</filename> - The Request object holds 
the state of the PyBlosxom request at any given time throughout the lifecycle 
of the request.  The Request is passed to most callbacks in the args dict 
as <varname>request</varname>.
</para>
</listitem>
<listitem>
<para>
<filename>Pyblosxom.pyblosxom.PyBlosxom</filename> - The PyBlosxom object holds 
a list of registered plugins, what callbacks they're registered to, and the methods 
that handle the the actual request. 
</para>
</listitem>
</itemizedlist>

<para>
The PyBlosxom request lifecycle starts with the web-server executing 
<filename>pyblosxom.cgi</filename>.
</para>

<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>
<filename>pyblosxom.cgi</filename> loads <filename>config.py</filename>
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> instantiates a Request object
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> instantiates a PyBlosxom object passing it the
Request object
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> calls run() on the PyBlosxom instance
</para>
<orderedlist numeration="arabic" spacing="normal">
   <listitem>
   <para>PyBlosxom instance, run method: calls initialize</para>
   <orderedlist numeration="arabic" spacing="normal">
      <listitem>
      <para>PyBlosxom instance, initialize method: imports the plugins</para>
      </listitem>
      <listitem>
      <para>PyBlosxom instance, initialize method: calls the entry parser
      callback to get a map of all the entry types we handle</para>
      </listitem>
   </orderedlist>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the start callback to allow plugins
   to do any initialization they need to do</para>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the handle callback allowing plugins
   to fully handle the request.
   </para>
   <para>If a plugin handles the request, the plugin should return a 
   <literal>1</literal> signifying it has done so.  At that point, PyBlosxom will
   stop trying to handle the request.  FINISHED</para>
   <para>If no plugin handles the request, then PyBlosxom will handle the request
   using the blosxom_handler.</para>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the end callback to allow plugins 
   to do any cleanup they need to do </para>
   </listitem>
   </orderedlist>
</listitem>
</orderedlist>
</sect1>

<sect1>
<title>Lifecycle of the blosxom_handler</title>
<para>
This describes what the blosxom_handler does. This is the default handler 
for PyBlosxom. It's called by the PyBlosxom instance in the run method if 
none of the plugins have handled the request already.
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>calls the renderer callback to get a renderer instance.</para>
<para>If none of the plugins return a renderer instance, then we go check to 
see if config.py has the renderer property set and use that.</para>
<para>If there is no renderer property set, we use the blosxom renderer 
which is found in the pyblosxom.PyBlosxom.renderer package.</para>
</listitem>
<listitem>
<para>calls the pathinfo callback which allows all the plugins to help 
figure out what to do with the HTTP URI/QUERYSTRING we've been given.</para>
</listitem>
<listitem>
<para>calls the filelist callback which returns a list of entries to render 
based on what the path info is.</para>
</listitem>
<listitem>
<para>calls the prepare callback which allows plugins to transform the entries 
and any other data in the Request object prior to rendering.</para>
</listitem>
<listitem>
<para>renders the entries.</para>
</listitem>
</orderedlist>
</sect1>

<sect1>
<title>Lifecycle of the blosxom Renderer</title>
<para>
The blosxom renderer renders the entries in a similar fashion to what 
Blosxom does. The blosxom renderer uses flavour templates and template 
variables. It also has a series of callbacks allowing plugins to modify 
templates and entry data at the time of rendering that specific piece.
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>renders the content_type template</para>
</listitem>
<listitem>
<para>calls the head callback and renders the head template</para>
</listitem>
<listitem>
<para>calls the date_head callback and renders the date_head template</para>
</listitem>
<listitem>
<para>for each story:</para>
   <orderedlist numeration="arabic" spacing="normal">
   <listitem>
   <para>if the mtime on this entry is different than the last entry, it 
   calls the date_foot callback, renders the date_foot template, calls the 
   date_head callback and renders the date_head template.</para>
   </listitem>
   <listitem>
   <para>calls the story callback and renders the story template</para>
   </listitem>
   </orderedlist>
</listitem>
<listitem>
<para>calls the date_foot callback and renders the date_foot template</para>
</listitem>
<listitem>
<para>renders the foot template (calls the foot callback</para>
</listitem>
</orderedlist>
</sect1>

<sect1>
<title>Callbacks</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Entry Parsers</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Pre-formatters and Post-formatters</title>
<para>
FIXME
</para>
</sect1>

<sect1>
<title>Renderers</title>
<para>
FIXME 
</para>
</sect1>
</chapter>
