<!--
  CHAPTER COMMENTS
-->
<chapter id="comments">
<title>Comments</title>
<para>
This chapter briefly walks you through installing the comments, trackback,
pingback, and CommentAPI plugins.
</para>
<para>
FIXME - this chapter needs some serious work.
</para>

<sect1 id="commentssummary">
<title>Summary</title>
<para>
PyBlosxom does not come with comments functionality built-in.  Instead,
comments are implemented as a plugin which people who are interested in
in having comments can install and everyone else can ignore.
</para>
<para>
You can get the comments plugin via a couple of different methods:
</para>
<orderedlist numeration="arabic">
<listitem>
<para>
You can get it in the
<a href="http://sourceforge.net/project/showfiles.php?group_id=67445&amp;package_id=145140">
contributed plugins pack</a>. This is probably the best and easiest way to get
the comments plugin.
</para>
</listitem>
<listitem>
<para>
You can ask on the pyblosxom-users mailing list to see if anyone has
a version of the comments plugin that meets your specific needs.
</para>
</listitem>
<listitem>
<para>
You can get it via CVS--there are instructions on the
<a href="http://cvs.sourceforge.net/viewcvs.py/pyblosxom/pyblosxom/contrib/plugins/comments/">
project page of our web-site</a>.
</para>
</listitem>
</orderedlist>
<para>
The comments plugin has a README file that holds information on installing
comments, traceback, pingback, and the commentAPI.  This is the README file
listed at the above url.
</para>
</sect1>

<sect1 id="installcomments">
<title>Installing the comments plugin</title>
<para>
Requirements:
</para>
<itemizedlist>
<listitem>
<para>PyXML - The comments plugin requires the PyXML module.  To install the
PyXML module, go here: http://pyxml.sourceforge.net/
</para>
</listitem>
<listitem>
<para>A directory the web-server has writable permissions to.</para>
</listitem>
</itemizedlist>

<para>
After making sure you have the requirements, do the following:
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>Copy <filename>contrib/plugins/comments/plugins/comments.py</filename> to 
your plugins directory.  Then add <literal>"comments"</literal> to the 
<varname>load_plugins</varname> property in your <filename>config.py</filename> 
file.</para>
</listitem>

<listitem>
<para>Comments are stored in a directory which will parallel the data
directory.  The comments themselves are stored as XML files named
entryname-datetime.suffix.  The comment system allows you to specify
the directory where the comment directory tree will stored, and the
suffix used for comment files.  You need to make sure that this
directory is writable by the pyblosxom CGI scripts.
</para>
<para>
Set <varname>comment_dir</varname> to the directory (in your data directory)
where you want the comments to be stored.  The default value is a
directory named <literal>comments</literal> in your data directory.
</para>
<para>
Set <varname>comment_ext</varname> to the change comment file extension.  The
default file extension is <literal>cmt</literal>.
</para>
</listitem>

<listitem>
<para>Copy the flavour files from the contrib/plugins/comments/flavours 
directory.  There are flavours for <filename>html</filename> and 
<filename>rss</filename>.  You should copy all the files to your data directory.</para>
<para>The "comment-story" template is used to format a single entry that 
has comments.</para>
<para>The "comment" template is used to format a single
comment/trackback/pingback.</para>
<para>The "comment-form" template provides the form used to enter new 
comments.</para>
</listitem>

<listitem>
<para>Edit the "comment-story", "comment", and "comment-form" templates. 
Variables that are available are:</para>
<para>
Available in the "story" and "comment-story" templates:
</para>

<programlisting role="ascii"><![CDATA[$num_comments - Contains an integer count of the number of comments
                associated with this entry
]]></programlisting>
   
<para>
Available in the "comment" template:
</para>

<programlisting role="ascii"><![CDATA[$cmt_title - the title of the comment
$cmt_description - the content of the comment or excerpt of the 
                   trackback/pingback
$cmt_link - the pingback link referring to this entry
$cmt_author - the author of the comment or trackback
$cmt_pubDate - the date and time of the comment/trackback/pingback
$cmt_source - the source of the trackback
]]></programlisting>

</listitem>
</orderedlist>
</sect1>

<sect1 id="addcommentsconf">
<title>Additional comments plugin configuration</title>
<sect2>
<title>Enabling email notification</title>
<para>
The comment system can notify you via e-mail when new
comments/trackbacks/pingbacks are posted.  If you want to enable this 
feature, add the following properties to your <filename>config.py</filename> file:
</para>

<programlisting role="ascii"><![CDATA[py['comment_smtp_server'] - your SMTP server
py['comment_mta_cmd']     - alternatively, the path to your MTA
py['comment_smtp_from']   - the address sending the notification
py['comment_smtp_to']     - the address receiving the notification
]]></programlisting>

<para>
For example:
</para>

<programlisting role="ascii"><![CDATA[py['comment_smtp_server'] = "localhost"
py['comment_mta_cmd']     = "/usr/bin/mail"
py['comment_smtp_from']   = "joe@joe.com"
py['comment_smtp_to']     = "joe@joe.com"
]]></programlisting>

</sect2>
</sect1>


<sect1 id="writecommenttemp">
<title>Writing comments plugin templates</title>
<para>
This should explain which flavour templates are in charge of what
using an example.
</para>

<programlisting role="ascii"><![CDATA[<div class="news">           <- story.html
<h2>$title</h2>               |
<div class="content">         |
...                           |
</div>                        |
links                         |
</div>                       <-
<div class="comments">       <- comment-story.html
<div class="comment">        <- comment.html
Posted by $blah at $blah      |
$blah                         |
</div>                       <-
<div class="comment">        <- comment.html
Posted by $blah at $blah      |
$blah                         |
</div>                       <-
<div class="commentform">    <- comment-form.html
form stuff here.              |
</div>                        |
</div>                       <-
]]></programlisting>

</sect1>

<sect1 id="dealwithspam">
<title>Dealing with comment spam</title>
<para>
Expect it to happen.  Some folks get comment spam trickling in and others
get a torrential downpour.  It's best to deal with it from the start.
</para>
<para>
As of contributed plugins pack 1.2, the comments plugin has a "comment_reject"
callback which allows other plugins to examine the comment and reject it
according to their individual heuristics.
</para>
<para>
Also, you can run multiple comment rejection plugins.  The comments plugin
calls them one after another until one has rejected the plugin or all have
said it's ok.
</para>
<para>
The recommended comment spam solution is <filename>akismetcomments</filename>
and <filename>check_javascript</filename>, in parallel.
<filename>akismetcomments</filename> uses
<a href="http://akismet.com/">Akismet</a>, a centralized comment spam database
and filter, and
<filename>check_javascript</filename> simply checks that the client's user
agent supports Javascript. (Spam bots almost never do.)
</para>

<sect2>
<title>akismetcomments</title>
<para>
<a href="http://akismet.com/">Akismet</a> is a spam filter service developed
and operated by <a href="http://automattic.com/">Automattic</a>, the people
behind <a href="http://wordpress.com/">WordPress</a>. Akismet maintains an
up-to-date blacklist, Bayesian filter, and other tools to determine whether
blog comments are spam or valid, ie "ham."
</para>
<para>
The <filename>akismetcomments</filename> plugin passes every comment on your
blog to Akismet, which decides whether the comment is spam or ham. If spam,
the comment is logged and discarded; if ham, it is posted to your blog.
</para>
<para>
To use <filename>akismetcomments</filename>, you'll need to
<a href="http://faq.wordpress.com/2005/10/19/api-key/">sign up for a
Wordpress.com API key</a>.
</para>
<para>
After you have your API key, copy <filename>akismetcomments.py</filename> and
<filename>akismet.py</filename> to your plugin directory. Add an
<varname>akismet_api_key</varname> config variable with to your API key to your
<filename>config.py</filename>. Also, make sure the <varname>baseurl</varname>
config variable is defined:
</para>

<programlisting role="ascii"><![CDATA[py['baseurl'] = "joe.com"
py['akismet_api_key] = "ABQIAAAAg88GzFz..."
]]></programlisting>

<para>
Finally, your blog's web server will need to be able to make outbound HTTP
connections on port 80 to <filename>api-key.rest.akismet.com</filename>. Some
hosting providers and firewalls may prevent this. If you're not sure about
this, check with your webmaster or hosting provider.
</para>
<para>
<filename>akismetcomments</filename> was written by
<a href="http://mako.cc/">Benjamin 'Mako' Hill</a> and
<a href="http://bwinton.latte.ca/">Blake Winton</a>.
</para>
</sect2>

<sect2>
<title>check_javascript</title>
<para>
Comment spam is usually sent by automated spam bots, which blindly send HTTP
POSTs to a large, static list of blog addresses. These spam bots have very
little in common with web browsers. In particular, they rarely parse or render
HTML, and even more rarely run Javascript.
</para>
<para>
Given this, Javascript can be an effective way to determine whether a comment was
submitted by a spam bot or a web browser. <filename>check_javascript</filename>
uses a small piece of Javascript on the client side to set the value of an
<variable>input</variable> element in the comment form, which it checks for on
the server.
</para>
<para>

To use <filename>check_javascript</filename>, first copy
<filename>check_javascript.py</filename> to your plugins directory. Then
include this hidden input element and Javascript in your flavour's
<variable>comment-form</variable> template:
</para>

<programlisting role="ascii"><![CDATA[
...
<input type="hidden" name="secretToken" id="secretTokenInput"
  value="pleaseDontSpam" />
</form>

<script type="text/javascript">
// used by check_javascript.py. this is almost entirely backwards compatible,
// back to 4.x browsers.
document.getElementById("secretTokenInput").value = "$blog_title";
</script>
]]></programlisting>

<para>
It's included in the <filename>comment-form.html</filename> template in the 
<filename>contrib/plugins/comments/flavours/</filename>, so if you use that
template, you're good to go.
</para>
<para>
<filename>check_javascript</filename> was written by
<a href="http://snarfed.org/">Ryan Barrett</a>.
</para>
</sect2>

<sect2>
<title>rolling your own</title>
<para>
It's not hard to roll your own comment rejection plugin.  First figure
out what the heuristics involved would be.  Then write a plugin with
a <function>cb_comment_reject</function> function in it.  In that
function, look at the data provided and reject the plugin if it seems
appropriate to do so.
</para>
<para> 
A basic template for writing a plugin to reject comments is as 
follows:
</para>
<example><title>Template for plugin for rejecting comments</title>

<programlisting role="python"><![CDATA["""
FIXME - Documentation for what your plugin does and how to set it up
goes here.

FIXME - License information goes here.

FIXME - Copyright information goes here.
"""
__author__      = "FIXME - your name and email address"
__version__     = "FIXME - version number and date released"
__url__         = "FIXME - url where this plugin can be found"
__description__ = "FIXME - one-line description of plugin"

def verify_installation(request):
    # FIXME - code to verify that this plugin is installed correctly 
    # here.

    return 1


def cb_comment_reject(args):
    req = args["request"]
    comment = args["comment"]

    blog_config = req.getConfiguration()

    # FIXME - code for figuring out whether this comment should
    # be rejected or not goes here.  If you want to reject the
    # comment, return 1.  Otherwise return 0.
]]></programlisting>

</example>
</sect2>
</sect1>

<sect1 id="installtrackback">
<title>Installing trackback</title>
<para>
FIXME - this text probably needs fixing.
</para>
<para>
If you want trackbacks, copy 
<filename>contrib/plugins/comments/plugins/trackback.py</filename> to your plugins 
directory.  Then add <literal>"trackback"</literal> to the 
<varname>load_plugins</varname> property in your <filename>config.py</filename> 
file.
</para>
<para>
If you want trackbacks you need to advertise the trackback ping URL
for a particular entry.
</para>
<para>
You advertise a manual trackback ping link.  You can do this by
inserting the following HTML in story.html and comment-story.html
files:
</para>

<programlisting role="html"><![CDATA[<a href="$base_url/trackback.cgi/$file_path" title="Trackback">TB</a> 
]]></programlisting>

<para>
You may need to change the $base_url/trackback.cgi portion of the
URL to match the way that you have configured your webserver / CGI 
scripts.
</para>

<para>
You can supply an embedded RDF description of the trackback ping:
</para>

<programlisting role="html"><![CDATA[<!--
  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:dc="http://purl.org/dc/elements/1.1/"
           xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
  <rdf:Description
    about="$base_url/$file_path"
    dc:title="$title"
    dc:identifier="$base_url/$file_path"
    trackback:ping="$base_url/trackback.cgi/$file_path"
 />
    </rdf:RDF>
-->
]]></programlisting>

<para>
You may need to change the $base_url/trackback.cgi portion of the
trackback:ping attribute to match the way that you have configured
your webserver / CGI scripts.
</para>
<para>
This RDF should also be inserted in story.html and
comment-story.html.  Since it is in an HTML comment, it doesn't
matter where you put it.
</para>
</sect1>

<sect1 id="installpingback">
<title>Installing pingback</title>
<para>
FIXME - this text probably needs fixing.
</para>
<para>
This requires Mark Pilgrim's rssfinder and rssparser modules to be installed 
(available from http://diveintomark.org/projects ).  It also requires the 
<filename>xmlrpc</filename> plugin to be installed.
</para>
<para>
If you want pingbacks, copy
<filename>contrib/plugins/comments/plugins/xmlrpc_pingback.py</filename> to your
plugins directory.  Make sure you have the <varname>base_url</varname> property
defined in your <filename>config.py</filename> file.  Then add 
<literal>"xmlrpc_pingback"</literal> to the <varname>load_plugins</varname> 
property in your <filename>config.py</filename> file.
</para>
</sect1>

<sect1 id="installcommentapi">
<title>Installing the CommentAPI</title>
<para>
FIXME - this text probably needs fixing.
</para>
<para>
If you want support for the CommentAPI, copy 
<filename>contrib/plugins/comments/plugins/commentAPI.py</filename> to your plugins 
directory.  If you enable CommentAPI in your RSS feed (see below), some RSS 
aggregator programs will provide an interface that can post a comment to a blog 
entry.
</para>
<para>
For more information on CommentAPI, the specification is at
http://wellformedweb.org/story/9 and a list of implementations is at
http://wellformedweb.org/news/35 .
</para>
<para>
You need to have comments.py installed in order for this to work.
</para>
<para>
Then you must add the CommentAPI tags to your RSS 2.0 feed.  The best 
way to do this is to add an XML namespace declaration to the rss
element:
</para>

<programlisting role="xml"><![CDATA[xmlns:wfw="http://wellformedweb.org/CommentAPI"
]]></programlisting> 

<para>
Then inside your RSS items you need to add a wfw:comment element:
</para>

<programlisting role="xml"><![CDATA[<wfw:comment>###commentAPI###/$file_path</wfw:comment>
]]></programlisting>

<para>    
where ###commentAPI### is replaced by the URI that you mapped your
CommentAPI.cgi to  At the moment, you need to map to a URI one level
below the $base_url of the blog
</para>
</sect1>

</chapter>
