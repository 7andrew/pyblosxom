<!--
  CHAPTER COMMENTS
-->
<chapter id="comments">
<title>Comments</title>
<para>
This chapter briefly walks you through installing the comments, trackback,
pingback, and CommentAPI plugins.
</para>

<sect1 id="commentssummary">
<title>Summary</title>
<para>
PyBlosxom does not come with comments functionality built-in.  Instead,
comments are implemented as a plugin which people who are interested in
in having comments can install and everyone else can ignore.
</para>
<para>
You can get the latest stable version of the comments plugin from the
<ulink url="http://sourceforge.net/project/showfiles.php?group_id=67445&amp;package_id=145140">
contributed plugins pack</ulink>. Alternatively, you can get the latest version
<ulink url="http://cvs.sourceforge.net/viewcvs.py/pyblosxom/pyblosxom/contrib/plugins/comments/">
from CVS</ulink>, which is even more recent, but may be broken. Caveat hacker!
</para>
<para>
The comments plugin also has a
<ulink url="http://pyblosxom.svn.sourceforge.net/viewvc/*checkout*/pyblosxom/trunk/contrib/plugins/comments/README">
README file</ulink> that has more information on installing comments, traceback,
pingback, and the commentAPI.
</para>
</sect1>

<sect1 id="installcomments">
<title>Installing the comments plugin</title>
<para>
Requirements:
</para>
<itemizedlist>
<listitem>
<para>A directory the web-server has writable permissions to.</para>
</listitem>
</itemizedlist>

<para>
After making sure you have the requirements, do the following:
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>Copy <filename>contrib/plugins/comments/plugins/comments.py</filename> to 
your plugins directory.  Then add <literal>"comments"</literal> to the 
<varname>load_plugins</varname> property in your <filename>config.py</filename> 
file.</para>
</listitem>

<listitem>
<para>Comments are stored in a directory which will parallel the data
directory.  The comments themselves are stored as XML files named
entryname-datetime.suffix.  The comment system allows you to specify
the directory where the comment directory tree will stored, and the
suffix used for comment files.  You need to make sure that this
directory is writable by the pyblosxom CGI scripts.
</para>
<para>
Set <varname>comment_dir</varname> to the directory (in your data directory)
where you want the comments to be stored.  The default value is a
directory named <literal>comments</literal> in your data directory.
</para>
<para>
Set <varname>comment_ext</varname> to the change comment file extension.  The
default file extension is <literal>cmt</literal>.
</para>
</listitem>

<listitem>
<para>Copy the flavour files from the contrib/plugins/comments/flavours 
directory.  There are flavours for <filename>html</filename> and 
<filename>rss</filename>. You should copy all the files to your data
directory.</para>

<para>The <filename>comment-story</filename> template is used to format a
single entry that has comments.</para>
<para>The <filename>comment</filename> template is used to format a single
comment/trackback/pingback.</para>
<para>The <filename>comment-form</filename> template provides the form used to
enter new comments.</para>
</listitem>

<listitem>
<para>Edit the <filename>comment-story</filename>,
<filename>comment</filename>, and <filename>comment-form</filename> templates.
Variables that are available are:</para>
<para>
Available in the <filename>story</filename> and
<filename>comment-story</filename> templates:
</para>

<programlisting role="ascii"><![CDATA[$num_comments - Contains an integer count of the number of comments
                associated with this entry
]]></programlisting>
   
<para>
Available in the <filename>comment</filename> template:
</para>

<programlisting role="ascii"><![CDATA[$cmt_title - the title of the comment
$cmt_description - the content of the comment or excerpt of the 
                   trackback/pingback
$cmt_link - the pingback link referring to this entry
$cmt_author - the author of the comment or trackback
$cmt_optionally_linked_author - the author, wrapped in an <a href> tag
                                to $cmt_link *if* it was provided
$cmt_pubDate - the date and time of the comment/trackback/pingback
$cmt_source - the source of the trackback
]]></programlisting>

</listitem>
</orderedlist>
</sect1>

<sect1 id="addcommentsconf">
<title>Additional comments plugin configuration</title>
<sect2>
<title>Enabling email notification</title>
<para>
The comment system can notify you via e-mail when new
comments/trackbacks/pingbacks are posted.  If you want to enable this 
feature, add the following properties to your <filename>config.py</filename> file:
</para>

<programlisting role="ascii"><![CDATA[py['comment_smtp_server'] - your SMTP server
py['comment_mta_cmd']     - alternatively, the path to your MTA
py['comment_smtp_from']   - the address sending the notification
py['comment_smtp_to']     - the address receiving the notification
]]></programlisting>

<para>
For example:
</para>

<programlisting role="ascii"><![CDATA[py['comment_smtp_server'] = "localhost"
py['comment_mta_cmd']     = "/usr/bin/mail"
py['comment_smtp_from']   = "joe@joe.com"
py['comment_smtp_to']     = "joe@joe.com"
]]></programlisting>

</sect2>
</sect1>


<sect1 id="writecommenttemp">
<title>Writing comments plugin templates</title>
<para>
This should explain which flavour templates are in charge of what
using an example.
</para>

<programlisting role="ascii"><![CDATA[<div class="news">           <- story.html
<h2>$title</h2>               |
<div class="content">         |
...                           |
</div>                        |
links                         |
</div>                       <-
<div class="comments">       <- comment-story.html
<div class="comment">        <- comment.html
Posted by $blah at $blah      |
$blah                         |
</div>                       <-
<div class="comment">        <- comment.html
Posted by $blah at $blah      |
$blah                         |
</div>                       <-
<div class="commentform">    <- comment-form.html
form stuff here.              |
</div>                        |
</div>                       <-
]]></programlisting>

</sect1>

<sect1 id="dealwithspam">
<title>Dealing with comment spam</title>
<para>
Expect it to happen.  Some folks get comment spam trickling in and others
get a torrential downpour.  It's best to deal with it from the start.
</para>
<para>
As of contributed plugins pack 1.2, the comments plugin has a
<literal>comment_reject</literal> callback which allows other plugins to
examine the comment and reject it according to their individual heuristics.
</para>
<para>
Also, you can run multiple comment rejection plugins.  The comments plugin
calls them one after another until one has rejected the plugin or all have
said it's ok.
</para>
<para>
The recommended comment spam solution is <filename>akismetcomments</filename>
and <filename>check_javascript</filename>, in parallel.
<filename>akismetcomments</filename> uses
<ulink url="http://akismet.com/">Akismet</ulink>, a centralized comment spam database
and filter, and
<filename>check_javascript</filename> simply checks that the client's user
agent supports Javascript. (Spam bots almost never do.)
</para>

<sect2>
<title>akismetcomments</title>
<para>
<ulink url="http://akismet.com/">Akismet</ulink> is a spam filter service
developed and operated by
<ulink url="http://automattic.com/">Automattic</ulink>, the people behind
<ulink url="http://wordpress.com/">WordPress</ulink>. Akismet maintains an
up-to-date blacklist, Bayesian filter, and other tools to determine whether
blog comments are spam or valid, ie "ham."
</para>
<para>
The <filename>akismetcomments</filename> plugin passes every comment on your
blog to Akismet, which decides whether the comment is spam or ham. If spam,
the comment is logged and discarded; if ham, it is posted to your blog.
</para>
<para>
To use <filename>akismetcomments</filename>, you'll need to
<ulink url="http://faq.wordpress.com/2005/10/19/api-key/">sign up for a
Wordpress.com API key</ulink>.
</para>
<para>
After you have your API key, copy <filename>akismetcomments.py</filename> and
<filename>akismet.py</filename> to your plugin directory. Add an
<varname>akismet_api_key</varname> config variable with to your API key to your
<filename>config.py</filename>. Also, make sure the <varname>baseurl</varname>
config variable is defined:
</para>

<programlisting role="ascii"><![CDATA[py['baseurl'] = "joe.com"
py['akismet_api_key] = "ABQIAAAAg88GzFz..."
]]></programlisting>

<para>
Finally, your blog's web server will need to be able to make outbound HTTP
connections on port 80 to <filename>api-key.rest.akismet.com</filename>. Some
hosting providers and firewalls may prevent this. If you're not sure about
this, check with your webmaster or hosting provider.
</para>
<para>
<filename>akismetcomments</filename> was written by
<ulink url="http://mako.cc/">Benjamin 'Mako' Hill</ulink> and
<ulink url="http://bwinton.latte.ca/">Blake Winton</ulink>.
</para>
</sect2>

<sect2>
<title>check_javascript</title>
<para>
Comment spam is usually sent by automated spam bots, which blindly send HTTP
POSTs to a large, static list of blog addresses. These spam bots have very
little in common with web browsers. In particular, they rarely parse or render
HTML, and even more rarely run Javascript.
</para>
<para>
Given this, Javascript can be an effective way to determine whether a comment was
submitted by a spam bot or a web browser. <filename>check_javascript</filename>
uses a small piece of Javascript on the client side to set the value of an
<varname>input</varname> element in the comment form, which it checks for on
the server.
</para>
<para>

To use <filename>check_javascript</filename>, first copy
<filename>check_javascript.py</filename> to your plugins directory. Then
include this hidden input element and Javascript in your flavour's
<varname>comment-form</varname> template:
</para>

<programlisting role="ascii"><![CDATA[
...
<input type="hidden" name="secretToken" id="secretTokenInput"
  value="pleaseDontSpam" />
</form>

<script type="text/javascript">
// used by check_javascript.py. this is almost entirely backwards compatible,
// back to 4.x browsers.
document.getElementById("secretTokenInput").value = "$blog_title";
</script>
]]></programlisting>

<para>
It's included in the <filename>comment-form.html</filename> template in the 
<filename>contrib/plugins/comments/flavours/</filename>, so if you use that
template, you're good to go.
</para>
<para>
<filename>check_javascript</filename> was written by
<ulink url="http://snarfed.org/">Ryan Barrett</ulink>.
</para>
</sect2>

<sect2>
<title>rolling your own</title>
<para>
It's not hard to roll your own comment rejection plugin.  First figure
out what the heuristics involved would be.  Then write a plugin with
a <function>cb_comment_reject</function> function in it.  In that
function, look at the data provided and reject the plugin if it seems
appropriate to do so.
</para>
<para> 
A basic template for writing a plugin to reject comments is as 
follows:
</para>
<example><title>Template for plugin for rejecting comments</title>

<programlisting role="python"><![CDATA["""
FIXME - Documentation for what your plugin does and how to set it up
goes here.

FIXME - License information goes here.

FIXME - Copyright information goes here.
"""
__author__      = "FIXME - your name and email address"
__version__     = "FIXME - version number and date released"
__url__         = "FIXME - url where this plugin can be found"
__description__ = "FIXME - one-line description of plugin"

def verify_installation(request):
    # FIXME - code to verify that this plugin is installed correctly 
    # here.

    return 1


def cb_comment_reject(args):
    req = args["request"]
    comment = args["comment"]

    blog_config = req.getConfiguration()

    # FIXME - code for figuring out whether this comment should
    # be rejected or not goes here.  If you want to reject the
    # comment, return 1.  Otherwise return 0.
]]></programlisting>

</example>
</sect2>
</sect1>

<sect1 id="installtrackback">
<title>Installing trackback</title>
<para>
If you want to support
<ulink url="http://www.sixapart.com/pronet/docs/trackback_spec">
trackbacks</ulink>, copy 
<filename>contrib/plugins/comments/plugins/trackback.py</filename> to your plugins 
directory.  Then add <literal>"trackback"</literal> to the 
<varname>load_plugins</varname> property in your <filename>config.py</filename> 
file.
</para>
<para>
If you want trackbacks you need to advertise the trackback ping URL
for a particular entry.
</para>
<para>
You advertise a manual trackback ping link.  You can do this by
inserting the following HTML in story.html and comment-story.html
files:
</para>

<programlisting role="html"><![CDATA[<a href="$base_url/trackback/$file_path" title="Trackback">TB</a> 
]]></programlisting>

<para>
The <literal>/trackback</literal> URL prefix is configurable with the 
<varname>trackback_urltrigger</varname> config variable.
</para>

<para>
You can supply an embedded RDF description of the trackback ping:
</para>

<programlisting role="html"><![CDATA[<!--
  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:dc="http://purl.org/dc/elements/1.1/"
           xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
  <rdf:Description
    about="$base_url/$file_path"
    dc:title="$title"
    dc:identifier="$base_url/$file_path"
    trackback:ping="$base_url/trackback/$file_path"
 />
    </rdf:RDF>
-->
]]></programlisting>

<para>
This RDF should also be inserted in story.html and
comment-story.html.  Since it is in an HTML comment, it doesn't
matter where you put it.
</para>
</sect1>

<sect1 id="installpingback">
<title>Installing pingback</title>
<para>
If you want to support
<ulink url="http://www.hixie.ch/specs/pingback/pingback">pingbacks</ulink>,
copy <filename>contrib/plugins/comments/plugins/xmlrpc_pingback.py</filename>
and <filename>contrib/xmlrpc_plugins/xmlrpc.py</filename>
to your plugins directory. Make sure you have the <varname>base_url</varname>
property defined in your <filename>config.py</filename> file. Then add
<literal>"xmlrpc_pingback"</literal> to the <varname>load_plugins</varname>
property in your <filename>config.py</filename> file.
</para>
<para>

You'll need to advertise a pingback link in your <filename>head</filename>
template. Add the following tag to the <varname>meta</varname> section:
</para>

<programlisting role="html"><![CDATA[  <link rel="pingback" href="http://joe.com/RPC" />
]]></programlisting>

<para>
Replace <literal>joe.com</literal> with your <varname>baseurl</varname>.
</para>
</sect1>

<sect1 id="installcommentapi">
<title>Installing the CommentAPI</title>
<para>
FIXME - this text probably needs fixing.
</para>
<para>
If you want to support
<ulink url="http://wellformedweb.org/story/9">CommentAPI</ulink>, copy 
<filename>contrib/plugins/comments/plugins/commentAPI.py</filename> to your plugins 
directory.  If you enable CommentAPI in your RSS feed (see below), some RSS 
aggregator programs will provide an interface that can post a comment to a blog 
entry.
</para>
<para>
You need to have comments.py installed in order for this to work.
</para>
<para>
Then you must add the CommentAPI tags to your RSS 2.0 feed.  The best 
way to do this is to add an XML namespace declaration to the rss
element:
</para>

<programlisting role="xml"><![CDATA[xmlns:wfw="http://wellformedweb.org/CommentAPI"
]]></programlisting> 

<para>
Then inside your RSS items you need to add a wfw:comment element:
</para>

<programlisting role="xml"><![CDATA[<wfw:comment>###commentAPI###/$file_path</wfw:comment>
]]></programlisting>

<para>    
where ###commentAPI### is replaced by the URI that you mapped your
CommentAPI.cgi to  At the moment, you need to map to a URI one level
below the $base_url of the blog
</para>
</sect1>

</chapter>
