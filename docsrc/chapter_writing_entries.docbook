<!--
  WRITING ENTRIES
-->
<chapter id="writingentries">
<title>Writing Entries</title>
<sect1>
<title>Categories</title>
<para>
Writing entries in PyBlosxom is fairly straightforward.  Each entry
is a single text file located somewhere in the directory tree of your
datadir.  The directory that the entry is in is the category the entry
is "filed under".  For example, if my datadir was 
<filename>/home/joe/myblog/entries</filename>
and I stored an entry named <filename>firstpost.txt</filename> in 
<filename>/home/joe/myblog/entries/status</filename> then the category for 
my entry would be <literal>/status</literal>.
</para>
<para>
Be careful when you create your categories--be sure to use characters
that are appropriate in directory names in the file system.
</para>
<para>
Don't worry about making sure you have all the categories you need up
front--you can add them as you need them.
</para>
</sect1>

<sect1>
<title>The Format of an Entry</title>
<para>
PyBlosxom entries consist of three parts: the title, the metadata, and
then the body of the entry.  The first line is title of the entry.  Then
comes the metadata of the entry (if any).  After the metadata comes the
body of the entry.
</para>
<para>
The title consists of a single line of plain text.  You can have whatever
characters you like in the title of your entry.  The title doesn't have
to be the same as the entry file name.
</para>
<para>
The metadata section is between the title line and the body of the entry.
It consists of a series of lines that start with the hash mark (#), then
a metadata variable name, then the metadata variable value.
</para>

<warning>
  <title>don't store the mtime in metadata</title>
  <para>
    Unfortunately, you cannot store the mtime of your blog entry in the 
    metadata of the entry itself.  The problem here is that we don't open
    the file and parse it for every blog entry to figure out what to 
    display.  By the time we've opened the file and parsed it to see the
    metadata inside, we already know which blog entries to show and it's
    too late to re-sort them.
  </para>
</warning>

<para>
The body of the entry is written in HTML and comprises the rest of the
entry file.
</para>
<para>
Here's an example first post entry:
</para>

<example><title>first post</title>
<programlisting role="html"><![CDATA[This is my first post!
<p>
  This is the body of the first post to my blog.
</p>
]]></programlisting>
</example>

<para>
Here's a more complex example:
</para>

<example><title>more complex first post</title>
<programlisting role="html"><![CDATA[The rain in Spain....
<p>
  The rain
</p>
<p align="center">
  in Spain
</p>
<p align="right">
  is <font color="ff0000">mainly</font> on the plain.
</p>
]]></programlisting>
</example>

<para>
Here's an example of a post with metadata:
</para>

<example><title>first post with metadata</title>
<programlisting role="html"><![CDATA[The rain in Spain....
#mood bored
#music The Doors - Greatest Hits Vol 1
<p>
  The rain
</p>
<p align="center">
  in Spain
</p>
<p align="right">
  is <font color="ff0000">mainly</font> on the plain.
</p>
]]></programlisting>
</example>

<para>
The metadata variables here would be available in your story template.  
So for the above example, the template variable <varname>$mood</varname> 
would be filled in with <literal>bored</literal> and <varname>$music</varname> 
would be filled in with <literal>The Doors - Greatest Hits Vol 1</literal>.
</para>
</sect1>

<sect1>
<title>Posting Date</title>
<para>
The posting date of the entry file is the modification time (also known as
mtime) on the file itself as stored by your file system.  Every time you 
go to edit an entry, it changes the modification time.  You can see this
in the following example of output:
</para>

<programlisting role="shell"><![CDATA[willg ~/blogdata/blosxom/site: vi testpost.txt                            [1]
willg ~/blogdata/blosxom/site: ls -l
total 16
-rw-r--r--  1 willg willg 764 Jul 20  2003 minoradjustments.txt
-rw-r--r--  1 willg willg 524 Jul 24  2003 moreminoradjustments.txt
-rw-r--r--  1 willg willg 284 Aug 15  2004 nomorecalendar.txt
-rw-r--r--  1 willg willg  59 Mar 21 16:30 testpost.txt                   [2]
willg ~/blogdata/blosxom/site: vi testpost.txt                            [3]
willg ~/blogdata/blosxom/site: ls -l
total 16
-rw-r--r--  1 willg willg 764 Jul 20  2003 minoradjustments.txt
-rw-r--r--  1 willg willg 524 Jul 24  2003 moreminoradjustments.txt
-rw-r--r--  1 willg willg 284 Aug 15  2004 nomorecalendar.txt
-rw-r--r--  1 willg willg  59 Mar 21 16:34 testpost.txt                   [4]
]]></programlisting>

<para>
[1] I create the blog entry <filename>testpost.txt</filename> using 
<command>vi</command> (a text editor).  The mtime of the file will be the 
time I last save the file and exit out of vi.
</para>
<para>
[2] See the mtime on the file is <literal>Mar 21 16:30</literal>.  That's when 
I last saved the blog entry and exited out of vi.
</para>
<para>
[3] I discover that I made a spelling mistake in my entry...  So I edit
it again in vi and fix the mistake.  The mtime of the entry has now changed...
</para>
<para>
[4] Now the mtime of the file is <literal>Mar 21 16:34</literal>.  This is 
the time that will show up in my blog as the posting date.
</para>

<warning>
  <title>be careful with the mtimes</title>
  <para>
    There are some issues with this method for storing the posting date.  First,
    if you ever change the blog entry, the mtime will change as well.  That
    makes updating blog entries very difficult down the line.
  </para>
  <para>
    There's a utility that comes with the contributed plugins pack called 
    <filename>editfile.py</filename>.  This will note the mtime of the file, 
    open up your favorite editor to edit the file, and when you're done, it'll 
    reset the mtime of the file back to what it was.
  </para>
</warning>
</sect1>

<sect1>
<title>Entry Parsers</title>
<para>
PyBlosxom supports only one format for entry files by default.  This format
is the same format that blosxom uses.  The extension for this format is 
<filename>.txt</filename>.  The first line of the file is in plain text and 
forms the title of the entry.  The second line through the end of the file is 
in HTML and is the body of the entry.
</para>
<para>
A sample blog entry could look like this:
</para>

<programlisting role="text"><![CDATA[First post
<p>
  Here's the body of my first post.
</p>
]]></programlisting>

<para>
Some people really detest writing in HTML which is valid.  Other 
people use their entries in other places, so they need a markup format 
that's less web-oriented.  Some folks write a lot of material in a non-HTML 
markup format and would like to use that same format for blog entries.  
These are all very valid reasons to want to use other markup formats.
</para>
<para>
PyBlosxom allows you to install entry parser plugins which are PyBlosxom 
plugins that implement an entry parser.  These entry parser plugins allow 
you to use other markup formats.  Check the Plugin Registry at 
http://pyblosxom.sourceforge.net/ for which entry parsers are available.
</para>
<para>
In general, we only have entry parsers written by people who really 
wanted that markup format.  If you don't see your favorite markup format 
represented, try looking at the code for other entry parsers and implement 
it yourself.  If you need help, talk to us on the pyblosxom-users or 
pyblosxom-devel mailing lists.
</para>
<para>
Details on the various entry parsers should be at the top of the entry
parser plugin itself in the Python doc-string.
</para>
</sect1>

<sect1>
<title>Beyond Editors</title>
<para>
There's no reason that all your entries have to come from editing blog entry
text files in your datadir.  You could rig up procmail to look for emails
that meet a certain description and convert those emails into blog entries.
</para>

<sect2>
<title>weblog-add</title>
<para>
You can find the weblog-add CGI script in the Plugin Registry at
http://pyblosxom.sourceforge.net/ .  This script allows you to create
entries using a webform.  It doesn't allow you to edit entries after
the fact and it's pretty basic.  However, it does work and it does allow
you to create entries when you don't have access to the filesystem.
</para>
<para>
To setup the weblog-add script, do the following:
</para>
<orderedlist numeration="arabic">
<listitem>
<para>
copy the <filename>weblog-add.py</filename> file into your CGI root
</para>
</listitem>
<listitem>
<para>
open up the <filename>weblog-add.py</filename> file in your favorite text 
editor and change the line for <varname>blog_root</varname> to your datadir
</para>
</listitem>
<listitem>
<para>
set up your cgi directory so that the web-server forces the user to
authenticate
</para>
<para>
FIXME - how do you do that?
</para>
</listitem>
<listitem>
<para>
make sure the weblog-add.py file has the correct permissions so that it 
will run as a CGI script
</para>
</listitem>
</orderedlist>
<para>
When you're using the <filename>weblog-add.py</filename> script, make sure 
you use unique file names.  That gets a bit hard as your blog gets so big 
that you don't remember what file names exist and what don't.
</para>
</sect2>

<sect2>
<title>Using w.bloggar</title>
<para>
PyBlosxom works with w.bloggar (http://www.wbloggar.com/).  In order to use 
w.bloggar you have to do the following:
</para>

<orderedlist numeration="arabic">
<listitem>
<para>
  install the xmlrpc plugin found at http://pyblosxom.sourceforge.net/ in the
  plugin registry
</para>
</listitem>
<listitem>
<para>
  install the xmlrpc_bloggar plugin found at http://pyblosxom.sourceforge.net/ 
  in the plugin registry
</para>
</listitem>
<listitem>
<para>
  in the Content Management System section of the w.bloggar account settings 
  dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Blog Tool" to "Custom"</para></listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  in the API Server tab section of the w.bloggar account settings dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Host" to the name of your server</para></listitem>
  <listitem>
    <para>"Page" to the url of your blog with /RPC at the end--
    For example, mine might be "/~joe/cgi-bin/pyblosxom.cgi/RPC"</para>
  </listitem>
</itemizedlist> 
</listitem>
<listitem>
<para>
  in the Custom tab section of the w.bloggar account settings dialog, set:
</para>
<itemizedlist>
  <listitem><para>"Posts" to "Blogger API"</para></listitem>
  <listitem><para>"Categories" to "Not supported"</para></listitem>
  <listitem><para>"Templates" to "Not supported"</para></listitem>
  <listitem><para>"Title Tags" should be blank</para></listitem>
  <listitem><para>"Category Tags" should be blank</para></listitem>
</itemizedlist>
</listitem>
</orderedlist>
<para>
When you go to write a new entry, leave the title field blank and do your 
entire post in the data section with the first line being the title (just 
like blosxom entries).
</para>
<para>
One thing you should note is that pyblosxom will take the first line and use 
that to generate the file name of the entry. So if the title of the entry is 
<literal>How to use w.bloggar with pyblosxom</literal>, the file name ends 
up being <filename>How_to_use_w_bloggar_with_pyblosxom.txt</filename> which 
may get a little annoying.
</para>
<para>
FIXME - Does this still work?
</para>
</sect2>

<sect2>
<title>Using Ecto</title>
<para>
FIXME - I need instructions for this
</para>
</sect2>

<sect2>
<title>Other blog tools?</title>
<para>
Does PyBlosxom work with other blog tools?
</para>
</sect2>

</sect1>
</chapter>
