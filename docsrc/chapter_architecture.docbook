<!--
  CHAPTER ARCHITECTURE
-->

<chapter id="pybarchitecture">
<title>PyBlosxom Architecture</title>
<para>
The architecture for PyBlosxom has evolved over time. The mission is to 
build an easily augmented blog server that uses the file system for data 
storage. Using the file system allows PyBlosxom to fit in with other 
applications rather than forcing PyBlosxom to solve all problems all by 
itself.
</para>
<para>
In general, this chapter is lacking pretty severely.  The code itself
is fairly well documented and you should always consider the code to be
an authority when the code and this manual are in disagreement.
</para>
<para>
FIXME - rework this whole chapter.
</para>

<sect1 id="architectureparts">
<title>Parts</title>
<para>
PyBlosxom is composed of several parts:
</para>
<itemizedlist>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> - This is the CGI script that is executed 
by your web-server, pulls in configuration variables from 
<filename>config.py</filename> and then instantiates PyBlosxom objects to 
handle the request.
</para>
</listitem>
<listitem>
<para>
the <filename>Pyblosxom</filename> package - This is the Python package that 
holds the PyBlosxom objects and utility functions that handle the request.
</para>
<itemizedlist>
   <listitem>
   <para>
   the <filename>entries</filename> package - Handles the abstraction allowing 
   PyBlosxom to use entries other than those solely found on the file system.
   </para>
   </listitem>
   <listitem>
   <para>
   the <filename>renderers</filename> package - PyBlosxom can handle different 
   renderers. The renderer gets a list of entries to be rendered and can render 
   them using whatever means it so desires: blosxom templates, htmltmpl templates, 
   Cheetah templates, hard-coded RSS 2.0 markup, ...
   </para>
   </listitem>
   <listitem>
   <para>
   the <filename>cache</filename> package - PyBlosxom allows for entry-level 
   caching. This helps in cases where your entries are stored in a format that 
   requires a lot of processing to convert to HTML. 
   </para>
   </listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
PyBlosxom's look'n'feel and behavior is then augmented by:
</para>

<itemizedlist>
<listitem>
<para>
plugins - Plugins allow you to augment PyBlosxom's default behavior. These 
you can get from the plugin registry or write yourself.
</para>
</listitem>
<listitem>
<para>
flavour templates - Flavour templates allow you to create the look and feel 
of your blog. These you can get from the flavour registry or write yourself. 
</para>
</listitem>
</itemizedlist>
</sect1>

<sect1 id="lifecyclerequest">
<title>Lifecycle of a PyBlosxom Request</title>
<para>
This is the life cycle of a single PyBlosxom request. It involves the 
following "entities":
</para>
<itemizedlist>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> - A script found in the web/ directory. 
This is the CGI script that handles PyBlosxom requests.
</para>
</listitem>
<listitem>
<para>
<filename>config.py</filename> - The configuration file that defines the 
behavior and properties of your blog.
</para>
</listitem>
<listitem>
<para>
<filename>PyBlosxom.pyblosxom</filename> - The pyblosxom module holds the 
default PyBlosxom behavior functions. It also defines the Request class and 
the PyBlosxom class.
</para>
</listitem>
<listitem>
<para>
<filename>Pyblosxom.pyblosxom.Request</filename> - The Request object holds 
the state of the PyBlosxom request at any given time throughout the lifecycle 
of the request.  The Request is passed to most callbacks in the args dict 
as <varname>request</varname>.
</para>
</listitem>
<listitem>
<para>
<filename>Pyblosxom.pyblosxom.PyBlosxom</filename> - The PyBlosxom object holds 
a list of registered plugins, what callbacks they're registered to, and the methods 
that handle the the actual request. 
</para>
</listitem>
</itemizedlist>

<para>
The PyBlosxom request lifecycle starts with the web-server executing 
<filename>pyblosxom.cgi</filename>.
</para>

<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>
<filename>pyblosxom.cgi</filename> loads <filename>config.py</filename>
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> instantiates a Request object
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> instantiates a PyBlosxom object passing it the
Request object
</para>
</listitem>
<listitem>
<para>
<filename>pyblosxom.cgi</filename> calls run() on the PyBlosxom instance
</para>
<orderedlist numeration="arabic" spacing="normal">
   <listitem>
   <para>PyBlosxom instance, run method: calls initialize</para>
   <orderedlist numeration="arabic" spacing="normal">
      <listitem>
      <para>PyBlosxom instance, initialize method: imports the plugins</para>
      </listitem>
      <listitem>
      <para>PyBlosxom instance, initialize method: calls the entry parser
      callback to get a map of all the entry types we handle</para>
      </listitem>
   </orderedlist>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the start callback to allow plugins
   to do any initialization they need to do</para>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the handle callback allowing plugins
   to fully handle the request.
   </para>
   <para>If a plugin handles the request, the plugin should return a 
   <literal>1</literal> signifying it has done so.  At that point, PyBlosxom will
   stop trying to handle the request.  FINISHED</para>
   <para>If no plugin handles the request, then PyBlosxom will handle the request
   using the blosxom_handler.</para>
   </listitem>
   <listitem>
   <para>PyBlosxom instance, run method: calls the end callback to allow plugins 
   to do any cleanup they need to do </para>
   </listitem>
   </orderedlist>
</listitem>
</orderedlist>
</sect1>

<sect1 id="lifecyclehandler">
<title>Lifecycle of the blosxom_handler</title>
<para>
This describes what the blosxom_handler does. This is the default handler 
for PyBlosxom. It's called by the PyBlosxom instance in the run method if 
none of the plugins have handled the request already.
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>calls the renderer callback to get a renderer instance.</para>
<para>If none of the plugins return a renderer instance, then we go check to 
see if config.py has the renderer property set and use that.</para>
<para>If there is no renderer property set, we use the blosxom renderer 
which is found in the pyblosxom.PyBlosxom.renderer package.</para>
</listitem>
<listitem>
<para>calls the pathinfo callback which allows all the plugins to help 
figure out what to do with the HTTP URI/QUERYSTRING we've been given.</para>
</listitem>
<listitem>
<para>calls the filelist callback which returns a list of entries to render 
based on what the path info is.</para>
</listitem>
<listitem>
<para>calls the prepare callback which allows plugins to transform the entries 
and any other data in the Request object prior to rendering.</para>
</listitem>
<listitem>
<para>renders the entries.</para>
</listitem>
</orderedlist>
</sect1>

<sect1 id="lifecyclerenderer">
<title>Lifecycle of the blosxom Renderer</title>
<para>
The blosxom renderer renders the entries in a similar fashion to what 
Blosxom does. The blosxom renderer uses flavour templates and template 
variables. It also has a series of callbacks allowing plugins to modify 
templates and entry data at the time of rendering that specific piece.
</para>
<orderedlist numeration="arabic" spacing="normal">
<listitem>
<para>renders the content_type template</para>
</listitem>
<listitem>
<para>calls the head callback and renders the head template</para>
</listitem>
<listitem>
<para>calls the date_head callback and renders the date_head template</para>
</listitem>
<listitem>
<para>for each story:</para>
   <orderedlist numeration="arabic" spacing="normal">
   <listitem>
   <para>if the mtime on this entry is different than the last entry, it 
   calls the date_foot callback, renders the date_foot template, calls the 
   date_head callback and renders the date_head template.</para>
   </listitem>
   <listitem>
   <para>calls the story callback and renders the story template</para>
   </listitem>
   </orderedlist>
</listitem>
<listitem>
<para>calls the date_foot callback and renders the date_foot template</para>
</listitem>
<listitem>
<para>renders the foot template (calls the foot callback</para>
</listitem>
</orderedlist>
</sect1>

<sect1 id="callbacks">
<title>Callbacks</title>
<para>
Callbacks allow plugins to override behavior in PyBlosxom or provide
additional behavior.  The callback mechanism actually encompasses a
series of different functions.  Callbacks can act as handlers, as
notifiers, and also as modifiers.
</para>

<sect2>
<title>Types of callbacks</title>
<para>
In the case of handler callbacks, PyBlosxom will query each plugin
implementing the callback until one of the plugins returns that it
has handled the callback.  At that point, execution of handling code
stops.  If none of the plugins handle the callback, then PyBlosxom
will run its default behavior code.
</para>
<para>
In the case of notifier callbacks, PyBlosxom will notify each
plugin implementing the callback regardless of return values.
</para>
<para>
In the case of modifier callbacks, PyBlosxom will query each plugin
implementing the callback passing in some input.  It takes the output
from the callback function and passes that in as input to the next
callback function.  In this way, each plugin has a chance to modify
and transform the data.
</para>
<para>
There's no reason you can't implement a handler-type callback and use
it for notification purposes--that's fine.  You should know that in the
case of handler callbacks and modifier callbacks, the return value that
your plugin gives will affect PyBlosxom's execution.
</para>
</sect2>

<sect2>
<title>Callbacks that have blosxom equivalents</title>
<para>
There are a series of callbacks in PyBlosxom that have equivalents
in blosxom 2.0.  The names are sometimes different and in most cases
the arguments the PyBlosxom versions take are different than the blosxom
2.0 versions.  Even so, the PyBlosxom versions serve the same purpose
as the blosxom 2.0 versions.
</para>
<para>
This isn't very interesting unless you're trying to implement the
functionality of a blosxom 2.0 plugin in Python for PyBlosxom.
</para>
<para>
The available blosxom renderer callbacks are:
</para>
<itemizedlist>
<listitem><para>cb_head - corresponds to blosxom 2.0 head</para></listitem>
<listitem><para>cb_date_head - corresponds to blosxom 2.0 date</para></listitem>
<listitem><para>cb_story - corresponds to blosxom 2.0 story</para></listitem>
<listitem><para>cb_foot - corresponds to blosoxm 2.0 foot</para></listitem>
</itemizedlist>

<para>
Additionally, we have these lifecycle callbacks available:
</para>
<itemizedlist>
<listitem><para>the blosxom 2.0 entries callback is handled by 
cb_filelist</para></listitem>
<listitem><para>the blosxom 2.0 filter callback is handled by 
cb_prepare</para></listitem>
<listitem><para>the blosxom 2.0 sort callback can sort of be handled by 
cb_prepare depending on what you're trying to do</para></listitem>
</itemizedlist>
</sect2>



<sect2>
<title>cb_prepare</title>
<para>
The prepare callback is called in the default blosxom handler after 
we've figured out what we're rendering and before we actually go to the
renderer.
</para>
<para>
Plugins should implement cb_prepare to modify the data dict which 
is in the Request.  Inside the data dict is entry_list
(amongst other things) which holds the list of entries to be renderered 
(in the order they will be rendered).
</para>
<para>
Functions that implement this callback will get an args dict
containing:
</para>
<itemizedlist>
<listitem><para>request - The Request object at the particular moment</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback can return whatever they want--it
doesn't affect the callback chain.
</para>
<para>
Example of a cb_prepare function in a plugin:
</para>

<example><title>Example of cb_prepare usage</title>
<programlisting role="python"><![CDATA[
def cb_prepare(args):
    """
    This plugin shows the number of entries we are going to render and
    place the result in $countNoOfEntries.
    """
    request = args['request']
    data = request.getData()
    config = request.getConfiguration()

    # Can anyone say Ternary? :)
    IF = lambda a,b,c:(a() and [b()] or [c()])[0]

    num_entry = config['num_entries']
    entries = len(data['entry_list'])

    data['countNoOfEntries'] = IF(num_entry > entries, num_entry, entries)

]]></programlisting>
</example>
</sect2>

<sect2>
<title>cb_logrequest</title>
<para>
The logrequest callback is used to notify plugins of the current 
PyBlosxom request for the purposes of logging.
</para>
<para>
Functions that implement this callback will get an args dict
containing:
</para>
<itemizedlist>
<listitem><para>filename - a filename (typically a base filename)</para></listitem>
<listitem><para>return_code - A HTTP error code (e.g 200, 404, 304)</para></listitem>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback can return whatever they want--it
doesn't affect the callback chain.
</para>
<para>
cb_logrequest is called after rendering and will contain all the
modifications to the Request object made by the plugins.
</para>
<para>
An example input args dict is like this::
</para>

<example><title>Example of cb_logrequest argument dict</title>
<programlisting role="python"><![CDATA[
{'filename': filename, 'return_code': '200', 'request': Request()}
]]></programlisting>
</example>

</sect2>



<sect2>
<title>cb_filelist</title>
<para>
The filelist callback allows plugins to generate the list of entries
to be rendered.  Entries should be EntryBase derivatives--either
by instantiating EntryBase, FileEntry, or creating your own
EntryBase subclass.
</para>
<para>
Functions that implement this callback will get an args dict
containing:
</para>
<itemizedlist>
<listitem><para>request - the PyBlosxom Request</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback should return None if they
don't plan on generating the entry list or a list of entries.
if they do.  When a function returns None, the callback will continue
to the next function to see if it will return a list of entries.
When a function returns a list of entries, the callback will stop.
</para>
</sect2>



<sect2>
<title>cb_filestat</title>
<para>
The filestat callback allows plugins to override the mtime of
the entry.  One of the contributed plugins uses this to set the
mtime to the time specified in the entry's filename.
</para>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>filename - the filename of the entry</para></listitem>
<listitem><para>mtime - the result of an os.stat on the filename of the 
entry</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
</sect2>



<sect2>
<title>cb_pathinfo</title>
<para>
The pathinfo callback allows plugins to parse the HTTP PATH_INFO
item.  This item is stored in the http dict of the Request object.
Functions would parse this as they desire, then set the following
variables in the data dict of the Request object:
</para>
<itemizedlist>
<listitem><para>bl_type - (dir|file)</para></listitem>
<listitem><para>pi_bl - typically the same as PATH_INFO</para></listitem>
<listitem><para>pi_yr - yyyy</para></listitem>
<listitem><para>pi_mo - (mm|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)</para></listitem>
<listitem><para>pi_da - dd</para></listitem>
<listitem><para>root_datadir - full path to the entry folder or entry file 
on filesystem</para></listitem>
<listitem><para>flavour - The flavour gathered from the URL</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback should make the modifications
to the data dict in place--no need to return anything.
</para>
</sect2>



<sect2>
<title>cb_renderer</title>
<para>
The renderer callback allows plugins to specify a renderer to use by
returning a renderer instance to use.  If no renderer is specified,
we use the default blosxom renderer.
</para>
<para>
Functions that implement this callback will get an args dict
containing:
</para>
<itemizedlist>
<listitem><para>request - the PyBlosxom Request</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback should return None if they
don't want to specify a renderer or the renderer object instanct
if they do.  When a function returns a renderer instance, processing
stops.
</para>
</sect2>



<sect2>
<title>cb_entryparser</title>
<para>
The entryparser callback allows plugins to register the entryparsers
they have.  Entry parsers are linked with a filename extension.  For
example, the default blosxom text entry parser will be used for
any file ending in ".txt".
</para>
<para>
Functions that implement this callback will get the entryparser
dict consisting of file extension -> entry parsing function pairs.
</para>
<para>
Functions that implement this callback should return the entryparser
dict after modifying it.
</para>
</sect2>



<sect2>
<title>cb_preformat</title>
<para>
The preformat callback acts in conjunction with the entryparser
that handled the entry to do a two-pass formatting of the entry.
</para>
<para>
Functions that implement cb_preformat are text transformation tools.
Once one of them returns a transformed entry, then we stop processing.
</para>
<para>
Functions that implement this callback will get an args dict
containing:
</para>
<itemizedlist>
<listitem><para>parser - a string that indicates whether a preformatter 
should run</para></listitem>
<listitem><para>story - a list containing lines of text (with '\n' 
included)</para></listitem>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback should return None if they
didn't modify the story or a single story string.
</para>
</sect2>



<sect2>
<title>cb_postformat</title>
<para>
The postformat callback allows plugins to make further modifications
to entry text.  It typically gets called after a preformatter by
the entryparser.  It can also be used to add additional properties
to entries.  The changes from postformat functions are saved in the
cache (if the user has caching enabled).  As such, this shouldn't
be used for dynamic data like comment counts.
</para>
<para>
Examples of usage:
</para>
<itemizedlist>
<listitem><para>adding a word count property to the entry</para></listitem>
<listitem><para>using a macro replacement plugin (Radio Userland 
glossary)</para></listitem>
<listitem><para>acronym expansion</para></listitem>
<listitem><para>a 'more' text processor</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>entry_data - a dict that minimally contains a "title" and
a "story"</para></listitem>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback don't need to return 
anything--modifications to the entry_data dict are done in place.
</para>
</sect2>



<sect2>
<title>cb_start</title>
<para>
The start callback allows plugins to execute startup/initialization code.
Use this callback for any setup code that your plugin needs, like:
</para>
<itemizedlist>
<listitem><para>reading saved data from a file</para></listitem>
<listitem><para>checking to make sure configuration variables are set</para></listitem>
<listitem><para>allocating resources</para></listitem>
</itemizedlist>
<note>
  <title>cb_start is different in PyBlosxom than in blosxom</title>
  <para>
    The cb_start callback is slightly different than in blosxom in 
    that cb_start is called for every PyBlosxom request regardless of 
    whether it's handled by the default blosxom handler.  In general,
    it's better to delay allocating resources until you absolutely know 
    you are going to use them.
  </para>
</note>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback don't need to return 
anything.
</para>
</sect2>



<sect2>
<title>cb_end</title>
<para>
The start callback allows plugins to execute teardown/cleanup code,
save any data that hasn't been saved, clean up temporary files,
and otherwise return the system to a normal state.
</para>
<para>
Examples of usage:
</para>    
<itemizedlist>
<listitem><para>save data to a file</para></listitem>
<listitem><para>clean up any temporary files</para></listitem>
</itemizedlist>
<para> 
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - a Request object</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback don't need to return 
anything.
</para>
<note>
  <title>cb_end is different in PyBlosxom than in blosxom</title>
  <para>
    The cb_end callback is called for every PyBlosxom request regardless
    of whether it's handled by the default blosxom handler.  This is slightly
    different than blosxom.
  </para>
</note>
</sect2>



<sect2>
<title>cb_head</title>
<para>
The head callback is called before a head flavour template is rendered.
</para>
<para>    
cb_head is called before the variables in the entry are substituted
into the template.  This is the place to modify the head template based
on the entry content.  You can also set variables on the entry that will
be used by the cb_story or cb_foot templates.  You have access to 
all the content variables via entry.
</para>
<para>    
Blosxom 2.0 calls this callback 'head'.
</para>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - the Request object</para></listitem>
<listitem><para>renderer - the BlosxomRenderer that called the callback</para></listitem>
<listitem><para>entry - a EntryBase to be rendered</para></listitem>
<listitem><para>template - a string containing the flavour template to 
be processed</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
<para>
Example in which we add the number of entries being rendered
to the $blog_title variable:
</para>

<example><title>Example of cb_head usage</title>
<programlisting role="python"><![CDATA[
def cb_head(args):
    request = args["request"]
    config = request.getConfiguration()
    data = request.getData()

    num_entries = len(data.get("entry_list", []))
    bt = config.get("blog_title", "")
    config["blog_title"] = bt + ": %d entries" % num_entries

    return args
]]></programlisting>
</example>
</sect2>


<sect2>
<title>cb_date_head</title>
<para>
The date_head callback is called before a date_head flavour template
is rendered.
</para>
<para>
cb_date_head is called before the variables in the entry are substituted
into the template.  This is the place to modify the date_head template 
based on the entry content.  You have access to all the content variables 
via entry.
</para>
<para> 
Blosxom 2.0 calls this callback 'date'.
</para>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - the Request object</para></listitem>
<listitem><para>renderer - the BlosxomRenderer that called the callback</para></listitem>
<listitem><para>entry - a EntryBase to be rendered</para></listitem>
<listitem><para>template - a string containing the flavour template to 
be processed</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
</sect2>



<sect2>
<title>cb_story</title>
<para>
The story callback gets called before the entry is rendered.
</para>
<para>
The template used is typically the story template, but we allow 
entries to override this if they have a "template" property.  If they 
have the "template" property, then we'll use that template instead.
</para>
<para>
cb_story is called before the variables in the entry are substituted
into the template.  This is the place to modify the story template based
on the entry content.  You have access to all the content variables via 
entry.
</para>
<para>
Blosxom 2.0 calls this callback 'story'.
</para>
<para>
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - the Request object</para></listitem>
<listitem><para>renderer - the BlosxomRenderer that called the callback</para></listitem>
<listitem><para>entry - a EntryBase to be rendered</para></listitem>
<listitem><para>template - a string containing the flavour template to 
be processed</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
</sect2>


<sect2>
<title>cb_story_end</title>
<para>
The story_end callback is is called after the variables in the entry 
are substituted into the template.  You have access to all the 
content variables via entry.
</para>
<para>    
Functions that implement this callback will get an args dict containing:
</para>
<itemizedlist>
<listitem><para>request - the Request object</para></listitem>
<listitem><para>renderer - the BlosxomRenderer that called the callback</para></listitem>
<listitem><para>entry - a EntryBase to be rendered</para></listitem>
<listitem><para>template - a string containing the flavour template to 
be processed</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
</sect2>



<sect2>
<title>cb_foot</title>
<para>
The foot callback is called before the variables in the entry are 
substituted into the foot template.  This is the place to modify the 
foot template based on the entry content.  You have access to all the 
content variables via entry.
</para>
<para>
Blosxom 2.0 calls this callback 'foot'.
</para>
<para>
Functions that implement this callback will get an args dict containing:
</para>    
<itemizedlist>
<listitem><para>request - the Request object</para></listitem>
<listitem><para>renderer - the BlosxomRenderer that called the callback</para></listitem>
<listitem><para>entry - a EntryBase to be rendered</para></listitem>
<listitem><para>template - a string containing the flavour template to 
be processed</para></listitem>
</itemizedlist>
<para>
Functions that implement this callback must return the input args
dict whether or not they adjust anything in it.
</para>
</sect2>
</sect1>


<sect1 id="archentryparsers">
<title>Entry Parsers</title>
<para>
FIXME
</para>
</sect1>

<sect1 id="preandpostformat">
<title>Pre-formatters and Post-formatters</title>
<para>
FIXME
</para>
</sect1>

<sect1 id="renderers">
<title>Renderers</title>
<para>
FIXME 
</para>
</sect1>
</chapter>
